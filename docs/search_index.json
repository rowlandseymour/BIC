[["index.html", "Bayesian Inference and Computation Practicalities 0.1 Module aims 0.2 Module structure 0.3 Assessment 0.4 Getting help 0.5 Recommended books and videos", " Bayesian Inference and Computation Dr Rowland Seymour Semester 2, 2023 Practicalities 0.1 Module aims The module aims to give you an overview of the Bayesian paradigm. By the end of the course, you should Be able to conceptualise a Bayesian approach for statistics Be able to derive posterior and posterior predictive distributions for uni- and multivariate models Identify suitable prior distributions and understand how the choice of prior distribution may affect the final result Understand the principles of Markov Chain Monte Carlo and be able to construct an MCMC algorithm 0.2 Module structure The module is split between theory and programming. Each week (excluding week 6) will have two lectures and two computer labs. 0.3 Assessment The module is 55% coursework and 45% exam. The exam will last 1h 30m and take place during the summer exam period. More details about the coursework will be announced during the semester. 0.4 Getting help There are lots of ways of getting help throughout the module. You can visit my office hour (Watson 317) on ….. or email me at r.g.seymour@bham.ac.uk. Each week, there will also be a problem class. 0.5 Recommended books and videos No books are required for this course and the whole material is contained in these notes. However, you may find it useful to use other resources in your studies. I recommend the following: A First Course in Bayesian Statistical Methods - Peter D. Hoff. This is a short book that covers the basics of Bayesian inference and computation. To the point and well written, it’s a useful place to look topics up. Bayesian Data Analysis - Andrew Gelman, John Carlin, Hal Stern, David Dunson, Aki Vehtari, and Donald Rubin. This is a thorough book explaining everything you’d need to know to carry out Bayesian data analysis. It’s a fairly look and in-depth book, but the authors are authoritative and give good advice throughout. Example code on the website is in R, Python and Stan. Statistical Rethinking - Richard McElrath. This book provides a friendly intuitive understanding of Bayesian inference and computation. Aimed at social and natural scientists, it has less theory that the other two books but is perhaps more approachable. A set of video lectures for this book can be found on YouTube. "],["fundamentals.html", "Chapter 1 Fundamentals of Bayesian inference 1.1 Statistical Inference 1.2 Frequentist Theory 1.3 Bayesian probability 1.4 Conditional Probability and Exchangability 1.5 Bayes’ Theorem 1.6 Exercises", " Chapter 1 Fundamentals of Bayesian inference Bayesian inference is built on a different way of thinking about probability that methods you have learnt so far. In the past 30 years or so, Bayesian inference has become much more popular. This is partly due to increased computational power becoming available. In this first chapter, we are going to set out: What are the fundamental principles of Bayesian inference? What makes Bayesian inference different from other methods? 1.1 Statistical Inference Three purpose of statistical inference is to “draw conclusions, from numerical data, about quantities that are not observed” (Bayesian Data Analysis, chapter 1). Generally speaking there are two kinds of inference: inference for quantities that are not possible to observe, and inference for quantities that unobserved or hasn’t happened yet. We can apply our inference methods to a huge range of applications, from the effectiveness of drugs in a clinical trial, to estimating the number of victims of violence against women and girls. In this module, we are going to look at a different way of carrying out statistical inference, one that doesn’t depend on long running event. Instead, we’re going to introduce the definition of probability that allows us to Interpret the subjective chance that an event occurs. 1.2 Frequentist Theory Frequentist theory is built on the theory on long run events. Probabilities must be interpretable as frequencies over multiple repetitions of the experiment that is being analysed, and are calculated from the sampling distributions of measured quantities. Definition 1.1 The long run relative frequency of an event is the probability of that event. Example 1.1 For example, if a frequentist wanted to assign a probability to rolling a 6 on a particular dice, then they would roll the dice a large number of times and compute the relative frequency. Definition 1.2 The sampling distribution of a statistic is the distribution based on a long run of samples of a fixed size from the population. These two definitions form the basis of frequentist statistics and give rise to higher-level objects. However, due to the long run condition, these objects are often misunderstood. Definition 1.3 Let \\(X\\) be a random sample from a probability distribution \\(\\theta\\). A 95% confidence interval for \\(\\theta\\) is an interval \\((u(X), v(X))\\) such that \\[ \\pi(u(X) &lt; \\theta &lt; v(X)) = 0.95 \\] This means that if you had an infinite number of samples for \\(X\\) and the corresponding infinite number of confidence intervals, then 95% of them would contain the true value of \\(\\theta\\). It does not mean that there is a 0.95 probability a particular interval contains the true value of \\(\\theta\\). Example 1.2 Suppose that a ornithologist believes that for the sex of an offspring of a certain species of bird is equally likely to be male or female and is independent of the sex of any siblings. They selects a random sample of 100 broods with 4 offspring and counts the number of male offspring in each. The results are summarised in the following table. offspring.df &lt;- data.frame(&quot;males&quot; = c(0, 1, 2, 3, 4), &quot;observed&quot; = c(5, 20, 50, 20, 5)) knitr::kable( offspring.df, booktabs = TRUE, caption = &#39;The number of males in each of the broods.&#39; ) Table 1.1: The number of males in each of the broods. males observed 0 5 1 20 2 50 3 20 4 5 If \\(X\\) denotes the number of male offspring then the scientist’s null hypothesis H0, is that \\(X \\sim Bin(4, 1/2)\\). This can be tested by calculating the so called \\(\\chi^2\\) statistic - which measures how well the observations conform to the supposed distribution. This is computed by expected &lt;- 100*dbinom(offspring.df$males, 4, 0.5) observed &lt;- offspring.df$observed ## Chi sq = sum of (expected - observed)^2/expected chi.sq &lt;- sum((expected - observed)^2/expected) Under H0, over repeated sampling the distribution of the \\(\\chi^2\\) statistic follows a \\(\\chi^2\\) distribution on 4 degrees of freedom. Therefore, the probability of seeing something as extreme as this (the p-value) is 1 - pchisq(chi.sq, 4) ## [1] 0.1545873 Consider now a second scientist who is more open-minded than their col- league. They hypothesise only that \\(X \\sim Bin(4, p)\\) where \\(p\\) is unknown. To test their H0 they first calculates the maximum likelihood estimator of \\(p\\), \\(\\hat{p}\\) = 0.5, computes the values of \\(E[X]\\) using this estimate and calculates \\(\\chi^2\\) to be 6.67 like their colleague. However, because they are estimating \\(p\\) as part of the process of computing \\(\\chi^2\\) over repeated sampling the distribution of their \\(\\chi^2\\) is (approximately) a \\(\\chi^2\\) distribution on 3 degrees of freedom. Their p-value is therefore 1 - pchisq(chi.sq, 3) ## [1] 0.08331631 We now have the somewhat confusing scenario whereby the second scientist finds that the evidence against their null hypothesis is stronger than that found by the first scientist against their null hypothesis, despite the second hypothesis being weaker (i.e. a logical consequence of the first). Thus, whatever a p-value represents, it must never be interpreted as the probability that the null hypothesis is true conditional on the observed data. In this example it simply tells us how extreme the observed values of \\(\\chi^2\\) are when compared to their distribution over many repetitions of the experiment. 1.3 Bayesian probability The Bayesian paradigm is built about a different definition of probability. We are simply building our view of statistics upon a different set of axioms. Definition 1.4 The subjective belief of an event is the probability of that event. This definition means we can assign probabilities to events that frequentists do not recognise as valid. Example 1.3 For example, The probability that I vote for the labour party at the next election A photo taken from the James Watt telescope contains a new planet. The real identify of Banksy is Robin Gunningham. These are not events that can be repeated in the long run. 1.4 Conditional Probability and Exchangability Before we derive Bayes’ theorem, we recap some important definitions in probability. Definition 1.5 Given two events \\(A\\) and \\(B\\), the conditional probability that event \\(A\\) occurs given the event \\(B\\) has already occurred is \\[ \\pi(A \\mid B) = \\frac{\\pi(A \\cap B)}{\\pi(B)}, \\] when \\(\\pi(B) &gt; 0\\). Definition 1.6 Two events \\(A\\) and \\(B\\) are independent given event \\(C\\) if \\[ \\pi(A \\cap B \\mid C) = \\pi(A \\mid C)\\pi(B \\mid C).\\] Definition 1.7 Let \\(\\pi(y_1, \\ldots, y_N)\\) be the joint density of \\(Y_1, \\ldots, Y_N\\). If \\(\\pi(y_1, \\ldots, y_N) = \\pi(y_{\\pi_1}, \\ldots, y_{\\pi_N})\\) for a permutations \\(\\pi\\) of \\(\\{1, \\ldots, N\\}\\), then \\(Y_1, \\ldots, Y_N\\) are exchangeable. Exchangability means that the labels of the random variables don’t contain any information about the outcomes. This is an important idea in many areas of probability and statistics, and we often model exchangeable events as iid. Example 1.4 If \\(Y_i \\sim Bin(n, p)\\) are independent and identically distributed for \\(i = 1, 2, 3\\), then \\(\\pi(Y_1, Y_2, Y_3) = \\pi(Y_3, Y_1, Y_2)\\). Example 1.5 Let \\((X, Y)\\) follow a bivariate normal distribution with mean 0, variances \\(\\sigma_x = \\sigma_y = 1\\) and a correlation parameter \\(\\rho \\in [-1, 1]\\). \\((X, Y)\\) are exchangable, but only independent if \\(\\rho = 0\\). Proposition 1.1 If \\(\\theta \\sim \\pi(\\theta)\\) and \\((Y_1, \\ldots, Y_N)\\) from a sample space \\(\\mathcal{Y}\\) are conditionally iid given some parameter \\(\\theta\\), then marginally \\(Y_1, \\ldots, Y_N\\) are exchangable. Proof. Suppose \\((Y_1, \\ldots, Y_N)\\) are conditionally iid given some parameter \\(\\theta\\). Then for any permutation \\(\\pi\\) of \\(\\{1, \\ldots, N\\}\\) and observations \\(\\{y_1, \\ldots, y_N\\}\\) \\[\\begin{equation} \\begin{split} \\pi(y_1, \\ldots, y_N) &amp;= \\int \\pi(y_1, \\ldots, y_N \\mid \\theta) \\pi(\\theta)\\, d\\theta \\qquad \\textrm{(definition of marginal distribution)}\\\\ &amp; = \\int \\left\\{\\prod_{i=1}^N\\pi(y_i \\mid \\theta)\\right\\} \\pi(\\theta)\\, d\\theta \\qquad \\textrm{(definition of conditionally iid)}\\\\ &amp; = \\int \\left\\{\\prod_{i=1}^N\\pi(y_{\\pi_i} \\mid \\theta)\\right\\} \\pi(\\theta)\\, d\\theta \\qquad \\textrm{(product is commutative)} \\\\ &amp; = \\pi(y_{\\pi_1}, \\ldots, y_{\\pi_N}) \\qquad \\textrm{(definition of marginal distribution)} \\end{split} \\end{equation}\\] This tells us that if we have some conditionally iid random variables and a subjective prior belief about some parameter \\(\\theta\\), then we have exchangeability. This is nice to have, but the implication in the other direction is much more interesting and powerful. Theorem 1.1 (de Finetti) If a sequence of random variables \\((Y_1, \\ldots, Y_N)\\) from a sample space \\(\\mathcal{Y}\\) is exchangeable, then its joint distribution can be written as \\[ \\pi(y_1, \\ldots, y_N) = \\int \\left\\{\\prod_{i=1}^N\\pi(y_i \\mid \\theta)\\right\\} \\pi(\\theta)\\, d\\theta \\] for some parameter \\(\\theta\\), some distribution on \\(\\theta\\), and some sampling model \\(\\pi(y_i \\mid \\theta)\\). This is a kind of existence theorem for Bayesian inference. It says that if we have exchangeable random varibales, then a parameter \\(\\theta\\) must exist and a subjective probability distribution \\(\\pi(\\theta)\\) must also exist. The argument against Bayesian inference is that it doesn’t guarantee a good subjective probability distribution \\(\\pi(\\theta)\\) exists. 1.5 Bayes’ Theorem Now we have an understanding of conditional probability and exchange ability, we can put these two together to understand Bayes’ Theorem. Bayes’ theorem is concerned with the distribution of the parameter \\(\\theta\\) given some observed data \\(y\\). It tries to answer the question: what does the data tell us about the model parameters? Theorem 1.2 (Bayes) The distribution of the model parameter \\(\\theta\\) given the data \\(y\\) is \\[ \\pi(\\theta \\mid y) = \\frac{\\pi(y \\mid \\theta)\\pi(\\theta)}{\\pi(y)} \\] Proof. \\[\\begin{align} \\pi(\\theta \\mid y) &amp;= \\frac{\\pi(\\theta, y)}{\\pi(y)}\\\\ \\implies \\pi(\\theta, y) &amp;= \\pi(\\theta \\mid y)\\pi(y) \\end{align}\\] Analogously, using \\(\\pi(y \\mid \\theta)\\) we can derive \\[ \\pi(\\theta, y) = \\pi(y \\mid \\theta)\\pi(\\theta) \\] Putting these two terms equal to each other and dividing by \\(\\pi(y)\\) gives \\[ \\pi(\\theta \\mid y) = \\frac{\\pi(y \\mid \\theta)\\pi(\\theta)}{\\pi(y)} \\] There are four terms in Bayes’ theorem: The posterior distribution \\(\\pi(\\theta \\mid y)\\). This tells us our belief about the model parameter \\(\\theta\\) given the data we have observed \\(y\\). The likelihood function \\(\\pi(y \\mid \\theta)\\). The likelihood function is common to both frequentist and Bayesian methods. By the likelihood principle, the likelihood function contains all the information the data can tell us about the model parameter \\(\\theta\\). The prior distribution \\(\\pi(\\theta)\\). This is the distribution that describes our prior beliefs about the value of \\(\\theta\\). The form of \\(\\theta\\) should be decided before we see the data. It may be a vague distribution (e.g. \\(\\theta \\sim N(0, 10^2)\\)) or a specific distribution based on prior information from experts (e.g. \\(\\theta \\sim N(5.5, 1.3^2)\\)). The evidence of the data \\(\\pi(y)\\). This is sometimes called the average probability of the data or the marginal likelihood. In practice, we do not need to derive this term as it can be back computed to ensure the posterior distribution sums/integrates to one. A consequence of point four is that posterior distributions are usually derived proportionally, and (up to proportionality) Bayes’ theorem \\[ \\pi(\\theta \\mid y) \\propto \\pi(y\\mid\\theta)\\pi(\\theta). \\] Some history of Thomas Bayes. Thomas Bayes was an English theologean born in 1702. His “Essay towards solving a problem in the doctrine of chances” was published posthumously. It intorduces theroems on conditional probability and the idea of prior probability. He discusses an experiment where the data can be modelled using the Binomial distirbution and he guesses (places a prior distirbution) on the probability of success. Richard Price sent Bayes’ work to the Royal Society two years after Bayes had died. In his commentary on Bayes’ work, he suggested that the Bayesian way of thinking proves the existance of God, stating: The purpose I mean is, to show what reason we have for believing that there are in the constitution of things fixt laws according to which things happen, and that, therefore, the frame of the world must be the effect of the wisdom and power of an intelligent cause; and thus to confirm the argument taken from final causes for the existence of the Deity. It’s not clear how Bayesian Thomas Bayes actually was, as his work was mainly about specific forms of probability theory and not his intepretation of it. The Bayesian way of thinking was really popularised by Laplace, who wrote about deductive probability in the early 19th century. Example 1.6 We finish this chapter with a very simple example. The advantage of the example being so simple is that we can obtain plots in R that show what’s going on. Suppose we have a model \\(y \\sim N(\\theta, 1)\\) and we want to estimate \\(\\theta\\). To do this we need to derive the posterior distribution. By Bayes’ theorem, \\[ \\pi(\\theta \\mid y) \\propto \\pi(y \\mid \\theta) \\pi(\\theta). \\] We know the form of \\(\\pi(y \\mid \\theta) = \\frac{1}{\\sqrt{2\\pi}}e^{\\frac{1}{2}(y - \\theta^2)}\\). But how should we describe our prior beliefs about \\(\\theta\\)? Here are three options: We can be very vague about \\(\\theta\\) – we genuinely don’t know about its value. We assign a uniform prior distribution to \\(\\theta\\) that takes values between -1,000 and +1,000, i.e. \\(\\theta \\sim u[-1000, 1000]\\). Up to proportionality \\(\\pi(\\theta) \\propto 1\\) for \\(\\theta \\in [-1000, 1000]\\). After thinking hard about the problem, or talking to an expert, we decide that the only thing we know about \\(\\theta\\) is that it can’t be negative. We adjust our prior distribution from 1. to be \\(\\theta \\sim u[0, 1000]\\). Up to proportionality \\(\\pi(\\theta) \\propto 1\\) for \\(\\theta \\in [0, 1000]\\). We decide to talk to a series of experts about \\(\\theta\\) asking for their views on likely values of \\(\\theta\\). Averaging the experts opinions gives \\(\\theta \\sim N(3, 0.7^2)\\). This is a method known as prior elicitation. We now go and observe some data. After a lot of time and effort, we collect one data point – \\(y = 0\\). Now we have all the ingredients to construct the posterior distribution. We multiply the likelihood function evaluated at \\(y = 0\\) by each of the three prior distributions. This gives us the posterior distributions (up to proportionality). #The likelihood function is the normal PDF #To illustrate this, we evaluate this from [-5, 5]. x &lt;- seq(-5, 5, 0.01) likelihood &lt;- dnorm(x, mean = 0, sd = 1) #The first prior distribution we try is a #uniform [-1000, 1000] distribution. This is a #vague prior distribution. uniform.prior &lt;- rep(1, length(x)) posterior1 &lt;- likelihood*uniform.prior #The second prior distribution we try is a uniform #[0, 1000] distribution, i.e. theta is non-negative. step.prior &lt;- ifelse(x &gt;= 0, 1, 0) posterior2 &lt;- likelihood*step.prior #The third prior distribution we try is a #specific normal prior distribution. It #has mean 3 and variance 0.7. normal.prior &lt;- dnorm(x, mean = 3, sd = 0.7) posterior3 &lt;- likelihood*normal.prior #Now we plot the likelihoods, prior and posterior distributions. #Each row corresponds to a different prior distribution. Each #column corresponds to a part in Bayes&#39; theorem. par(mfrow = c(3, 3)) plot(x, likelihood, type = &#39;l&#39;, xlab = &quot;&quot;, ylab = &quot;&quot;, yaxt = &quot;n&quot;, main = &quot;Likelihood&quot;) plot(x, uniform.prior, type = &#39;l&#39;, yaxt = &quot;n&quot;, xlab = &quot;&quot;, ylab = &quot;&quot;, main = &quot;Prior&quot;) plot(x, posterior1, type = &#39;l&#39;, yaxt = &quot;n&quot;, xlab = &quot;&quot;, ylab = &quot;&quot;, main = &quot;Posterior&quot;) plot(x, likelihood, type = &#39;l&#39;, xlab = &quot;&quot;, ylab = &quot;&quot;, yaxt = &quot;n&quot;) plot(x, step.prior, type = &#39;l&#39;, yaxt = &quot;n&quot;, xlab = &quot;&quot;, ylab = &quot;&quot;) plot(x, posterior2, type = &#39;l&#39;, yaxt = &quot;n&quot;, xlab = &quot;&quot;, ylab = &quot;&quot;) plot(x, likelihood, type = &#39;l&#39;, xlab = &quot;&quot;, ylab = &quot;&quot;, yaxt = &quot;n&quot;) plot(x, normal.prior, type = &#39;l&#39;, yaxt = &quot;n&quot;, xlab = &quot;&quot;, ylab = &quot;&quot;) plot(x, posterior3, type = &#39;l&#39;, yaxt = &quot;n&quot;, xlab = &quot;&quot;, ylab = &quot;&quot;) The posterior distribution is proportional to the likelihood function. The prior distribution closely matches frequentist inference. Both the MLE and posterior mean are 0. We get a lopsided posterior distribution, that is proportional to the likelihood function for positive values of \\(\\theta\\), but is 0 for negative values of \\(\\theta\\). 3.We get some sort of average of the likelihood function and the prior distribution. Had we collected more data, the posterior distribution would have been weighted toward the information from the likelihood function more. 1.6 Exercises Exercise 1.1 Consider a standard pack of 52 playing cards. You pick a card at random, what is the probability you pick: 1. A Queen, given you have picked a picture card (King, Queen, Jack)? 2. The five of clubs, given you have picked a black card? 3. A black card, given you have not picked the five of clubs? ::: {.solution} A pack of playing cards is equally divided into four suits: Hearts (red), Diamonds (red), Clubs (black), and Spades (black). Each suit has 13 cards numbered 2 - 10, Jack, Queen, King (all three picture cards), and Ace. \\[\\begin{align*} P(\\hbox{Queen} \\mid \\hbox{Picture}) &amp;= \\frac{P(\\hbox{Queen and Picture})}{P(\\hbox{Picture)}} \\\\ &amp; = \\frac{4/52}{12/52} \\\\ &amp; = \\frac{1}{3}. \\end{align*}\\] \\[\\begin{align*} P(\\hbox{5 Clubs} \\mid \\hbox{Black}) &amp;= \\frac{P(\\hbox{5 Clubs and Black})}{P(\\hbox{Black)}} \\\\ &amp; = \\frac{1/52}{1/2} \\\\ &amp; = \\frac{1}{26}. \\end{align*}\\] \\[\\begin{align*} P(\\hbox{Black} \\mid \\hbox{Not 5 Clubs}) &amp; = \\frac{P(\\hbox{Black} \\mid \\hbox{Not 5 Clubs})}{P(\\hbox{Not 5 Clubs})} \\\\ &amp; = \\frac{25/52}{51/52}\\\\ &amp;= \\frac{25}{51}. \\end{align*}\\] Exercise 1.2 Decide if each of the following events can be assigned probabilities by frequentists: 1. The Bermuda triangle exists. 2. Getting a 6 when rolling a dice. 3. Someone will test positive for Covid-19 after contracting the disease. 4. The sun will rise tomorrow. Solution. No, this can’t be assigned a probability. Yes, you can repeatedly roll of dice. Yes, this can be assigned a probability. You can repeatedly test someone for the disease, hence there is a long-run frequency of the test returning a positive result. It depends what you mean by tomorrow. Suppose today is 1st January 2023, if tomorrow means 2nd January 2023, then no. 2nd January 2023 will on occur once and there is no long-run frequency. If, however, you define tomorrow by the day after today, then yes. There have been many (The Earth has been going round the Sun for ~4.5 billion years, so approxiomamtely 4.5*365 tomorrows), so it can be assigned a probability. Exercise 1.3 An urn contains three coins. Two of the coins are fair, but one of the coins has heads on both sides. 1. You pick a coin out of the urn without looking and flip it. What’s the probability you get heads? 2. You pick a coin out of the urn without looking and flip it and get heads. What’s the probability it’s the two-headed coin? Solution. Label the coins 1, 2, 3, where \\(P(\\hbox{Heads} \\mid \\hbox{Coin } 1) = P(\\hbox{Heads} \\mid \\hbox{Coin } 2) = \\frac{1}{2}\\) and \\(P(\\hbox{Heads} \\mid \\hbox{Coin } 3) = 1\\). Using the law of total probability \\[\\begin{align*} P(\\hbox{Heads}) &amp; = P(\\hbox{Heads} \\mid \\hbox{Coin } 1) P(\\hbox{Coin } 1) + \\\\ &amp; \\qquad P(\\hbox{Heads} \\mid \\hbox{Coin } 2) P(\\hbox{Coin } 2) + P(\\hbox{Heads} \\mid \\hbox{Coin } 3) P(\\hbox{Coin } 3) \\\\ &amp; = \\frac{1}{2}\\cdot\\frac{1}{3} + \\frac{1}{2}\\cdot\\frac{1}{3} + 1\\cdot\\frac{1}{3} \\\\ &amp; = \\frac{2}{3}. \\end{align*}\\] Using Bayes’ theorem \\[\\begin{align*} P(\\hbox{Coin 1}\\mid \\hbox{Heads}) &amp;= \\frac{P(\\hbox{Heads} \\mid \\hbox{Coin 1})P(\\hbox{Coin 1})}{P(\\hbox{Heads})} \\\\ &amp; = \\frac{1\\cdot\\frac{1}{3}}{\\frac{2}{3}} \\\\ &amp; = \\frac{1}{2}. \\end{align*}\\] Exercise 1.4 You see a sponsored post online with the word bitcoin in. You want to work out the probability the post is spam. Using the law of total probability, show the probability the spac is spam, given it contains the word probability is \\[ \\pi(\\textrm{spam} \\mid \\textrm{bitcoin}) = \\frac{\\pi(\\textrm{bitcoin} \\mid \\textrm{spam})\\pi(\\textrm{spam})}{\\pi(\\textrm{bitcoin} \\mid \\textrm{spam})\\pi(\\textrm{spam}) + \\pi(\\textrm{bitcoin} \\mid \\textrm{not spam})\\pi(\\textrm{not spam})} \\] Most spam filters take a naive approach and set \\[ \\pi(\\textrm{spam}) =\\pi(\\textrm{not spam}) = \\frac{1}{2}. \\] If an post is known to be spam, there’s an 80% chance it contains the word bitcoin. If an post is not spam, then there’s a 1% chance it contains the word bitcoin. Calculate the probability the post is spam given it contains bitcoin. Suppose you take a much more pessimistic view, and assume that 80% of all sponsered posts are spam. Recalculate the probability the post is spam given it contains bitcoin. Solution. By Bayes’ theorem, we have \\[ \\pi(\\textrm{spam} \\mid \\textrm{bitcoin}) = \\frac{\\pi(\\textrm{bitcoin} \\mid \\textrm{spam})\\pi(\\textrm{spam})}{\\pi(\\textrm{bitcoin})}. \\] 1. By the law of total probability, \\[ \\pi(\\textrm{bitcoin}) = \\pi(\\textrm{bitcoin} \\mid \\textrm{spam})\\pi(\\textrm{spam}) + \\pi(\\textrm{bitcoin} \\mid \\textrm{not spam})\\pi(\\textrm{not spam}). \\] Thus, \\[ \\pi(\\textrm{spam} \\mid \\textrm{bitcoin}) = \\frac{\\pi(\\textrm{bitcoin} \\mid \\textrm{spam})\\pi(\\textrm{spam})}{\\pi(\\textrm{bitcoin} \\mid \\textrm{spam})\\pi(\\textrm{spam}) + \\pi(\\textrm{bitcoin} \\mid \\textrm{not spam})\\pi(\\textrm{not spam})} \\] From the question, we have \\(\\pi(\\textrm{spam}) =\\pi(\\textrm{not spam}) = \\frac{1}{2}\\), \\(\\pi(\\textrm{bitcoin} \\mid \\textrm{spam}) = 0.8\\) and \\(\\pi(\\textrm{bitcoin} \\mid \\textrm{not spam}) = 0.01\\). Plugging these into the probability gives \\[ \\pi(\\textrm{spam} \\mid \\textrm{bitcoin}) = \\frac{80}{81} \\approx 98.7\\%. \\] This time \\(\\pi(\\textrm{spam}) = 0.8\\) and \\(\\pi(\\textrm{not spam}) = 0.2\\), which yields \\[ \\pi(\\textrm{spam} \\mid \\textrm{bitcoin}) = \\frac{320}{321} \\approx 99.7\\%. \\] Exercise 1.5 You are working on a project investigating pollution related illnesses in the West Midlands. I have sampled the proportion of people with pollution related illnesses in five areas of the West Midlands, \\(y_1, \\ldots, y_5\\), with nothing to distinguish the data. This exercise is about the last data point \\(y_5\\). Should you model these data points exchangeably? I now tell you the first four of these rates (0.72, 1.00, 0.85, 0.78 per 100,000). Should you continue to model these data points exchangeably? Now, suppose instead of telling you these four rates, I had told you the five areas I have information about are Birmingham City Centre, Smethwick, Edgbaston, Dorridge, and Sutton Coldfield. Should you continue to model these data points exchangeably? Now suppose I give you the data in part 2 and say that the missing data point \\(y_5\\) is Birmingham City Centre. Should you continue to model these data points exchangeably? Solution. This is based on Gelman et. al (2013, p. 105). Yes, you have no information to distinguish the data points so exchangability seems a reasonable assumption. Yes, you still have no information to distinguish between any of the data points. Yes, the joint distribution of these variables doesn’t depend on the labels. However, you may start to formulate prior beliefs. Birmingham City Centre and Smethwick are likely to have higher rates of air pollution than leafy Dorridge. No, these can no longer be modelled exchangably. You have reason to believe that Birmingham City Centre is likely to have a substantially higher value than the rest. That is you have information about \\(\\pi(y_5 &gt; \\max(y_1, y_2, y_3, y_4) \\mid y_1, y_2, y_3, y_4)\\), so exchangability is no longer a suitable assumption. "],["bayesian-inference.html", "Chapter 2 Bayesian Inference 2.1 The Binomial Distirbution 2.2 Reporting Conclsuions from Bayesian Inference 2.3 The Exponential Distribution 2.4 The Normal Distribtuion 2.5 Predicition 2.6 Non-informative Prior Distibrutions 2.7 Bernstein-von-Mises Theorem 2.8 Exercises", " Chapter 2 Bayesian Inference Whereas Chapter 1 dealt with the fundamentals of Bayesian inference and definitions, Chapter 2 is much more practical. We’re going to be deriving posterior distributions and proving when it does and doesn’t work. 2.1 The Binomial Distirbution The first example we’re going to go through is with the binomial distribution. Example 2.1 A social media company wants to determining how many of its users are bots. A software engineering collects a random sampler of 200 accounts and finds that eight are bots. She uses a Bayesian method to estimate the probability of an account being a bot. She labels the accounts with a 1 if they are a bot and 0 if there is are a real person. The set of account labels is given by \\(\\boldsymbol{y} = \\{y_1, \\ldots, y_{200}\\}\\) and the probability an account is a bot is \\(\\theta\\). By Bayes’ theorem \\[ \\pi(\\theta \\mid \\boldsymbol{y}) \\propto \\pi(\\boldsymbol{y}\\mid \\theta) \\pi(\\theta). \\] Likelihood function \\(\\pi(\\boldsymbol{y}\\mid \\theta)\\). We observe a 200 trials each with a probability of success or failure. The binomial distribution seems the most suitable way of modelling this. Therefore \\[ \\pi(\\boldsymbol{y}\\mid \\theta) = \\begin{pmatrix} 200 \\\\ 3 \\end{pmatrix} \\theta^3(1-\\theta)^{197} \\] We are going to assume the accounts are independent. Prior distribution \\(\\pi(\\theta)\\). We now need to describe our prior beliefs about \\(\\theta\\). We have no reason to suggest \\(\\theta\\) takes any specific value, so we use a uniform prior distribution \\(\\theta \\sim U[0, 1]\\), where \\(\\pi(\\theta) = 1\\) for \\(\\theta \\in [0, 1]\\). Posterior distribution \\(\\pi(\\theta \\mid \\boldsymbol{y})\\). We can now derive the posterior distribution up to proportionality \\[ \\pi(\\theta \\mid \\boldsymbol{y}) \\propto \\theta^3(1-\\theta)^{197}. \\] This functional dependence on p identifies the \\(\\pi(\\theta \\mid \\boldsymbol{y})\\) as a Beta distribution. The PDF for the beta distribution with shape parameters \\(\\alpha\\) and \\(\\beta\\) is \\[ \\pi(x \\mid \\alpha, \\beta) = \\frac{\\Gamma(\\alpha + \\beta)}{\\Gamma(\\alpha)\\Gamma(\\beta)}x^{\\alpha - 1}(1-x)^{\\beta - 1}. \\] The posterior distribution is therefore \\(\\theta \\mid \\boldsymbol{y} \\sim \\textrm{Beta}(4, 198)\\). 2.2 Reporting Conclsuions from Bayesian Inference In the previous example, we derived the posterior distribution \\(\\theta \\mid \\boldsymbol{y} \\sim \\textrm{Beta}(4, 198)\\). But often, we want to share more descriptive information about our beliefs given the observed data. In this example, the posterior mean given the data is \\(\\frac{4}{198} = \\frac{2}{99}\\). That is to say given the data, we expect that for every 99 accounts , two to be bots. The posterior mode for \\(\\theta\\) is \\(\\frac{3}{200}\\) or 1.5%. It is important to share the uncertainty about out beliefs. In a frequentist framework, this would be via a confidence interval. The Bayesian analogues is a credible interval. Definition 2.1 A credible interval is a central interval of posterior probability which corresponds, in the case of a 100\\((1-\\alpha)\\)% interval, to the range of values that capture 100\\((1-\\alpha)\\)% of the posterior probability. Example 2.2 The 95% credible interval for the Binomial example is given by cred.int.95 &lt;- qbeta(c(0.025, 0.975), 4, 198) round(cred.int.95, 3) ## [1] 0.005 0.043 This says that we believe there is a 95% chance that the probability of an account being a bot lies between 0.005 and 0.043. This is a much more intuitive definition to the confidence interval, which says if we ran the experiment an infinite number of times and computed an infinite number of confidence intervals, 95% of them would contain the true value of \\(\\theta\\). 2.3 The Exponential Distribution Example 2.3 An insurance company want to estimate the time until a claim is made on a specific policy. They describe the rate at which claims come in by \\(\\lambda\\). The company provides a sample of 10 months at which a claim was made \\(\\boldsymbol{y} = \\{14, 10, 6, 7, 13, 9, 12, 7, 9, 8\\}\\). By Bayes’ theorem, the posterior distribution for \\(\\lambda\\) is \\[ \\pi(\\lambda \\mid \\boldsymbol{y}) \\propto \\pi(\\lambda \\mid \\boldsymbol{y}) \\pi(\\lambda) \\] Likelihood function \\(\\pi(\\lambda \\mid \\boldsymbol{y})\\). The exponential distribution is a good way of modelling lifetimes or the length of time until an event happens. Assuming all the claims are independent, the likelihood function is given by \\[\\begin{align*} \\pi(\\boldsymbol{y} \\mid \\lambda) &amp;= \\prod_{i=1}^{10} \\lambda e^{-\\lambda y_i} \\\\ &amp; = \\lambda^{10}e^{-\\lambda \\sum_{i=1}^{10} y_i} \\\\ &amp; = \\lambda^{10} e^{-95\\lambda} \\end{align*}\\] Prior distribution \\(\\pi(\\lambda)\\). As we are modelling a rate parameter, we know it must be positive and continuous. We decide to use an exponential prior distribution for \\(\\lambda\\), but leave the choice of the rate parameter up to the insurance professionals at the insurance company. The prior distribution is given by \\(\\pi(\\lambda) \\sim \\textrm{Exp}(\\chi).\\) Posterior distribution \\(\\pi(\\lambda \\mid \\boldsymbol{y})\\). We now have all the ingredients to derive the posterior distribution. It is given by \\[\\begin{align*} \\pi(\\lambda \\mid \\boldsymbol{y}) &amp;\\propto \\lambda^{10} e^{-95\\lambda} \\times \\lambda e^{-\\chi\\lambda} \\\\ &amp; \\propto \\lambda^{11}e^{-(95 + \\chi)\\lambda} \\end{align*}\\] The functional form tells us that the posterior distribution is a Gamma distribution. The PDF of a gamma random variable with shape \\(\\alpha\\) and rate \\(\\beta\\) is \\[ \\pi(x \\mid \\alpha, \\beta) = \\frac{\\alpha^\\beta}{\\Gamma(\\alpha)}x^{\\alpha-1}e^{-\\beta x}. \\] The distribution of the rate of the claims given the observed data is \\(\\lambda \\mid \\boldsymbol{y} \\sim \\textrm{Gamma}(10, 95 + \\chi)\\). The posterior mean months until a claim is \\(\\frac{10}{95 + \\chi}\\). We can see the effect of the choice of rate parameter in this mean. Small values of \\(\\chi\\) yield vague prior distribution, which plays a minimal role in the posterior distribution. Large values of \\(\\chi\\) result in prior distributions that contribute a lot to the posterior distribution. The plots below show the prior and posterior distributions for \\(\\chi = 0.01\\) and \\(\\chi = 50\\). plot.distributions &lt;- function(chi){ #evaluate at selected values of theta theta &lt;- seq(0.001, 0.3, 0.001) #evaluate prior density prior &lt;- dexp(theta, rate = chi) #evaluate posterior density posterior &lt;- dgamma(theta, shape = 10, rate = 95 + chi) #plot plot(theta, posterior, type= &#39;l&#39;, ylim = c(0, 50), xlab = expression(theta), ylab = &quot;density&quot;) lines(theta, prior, lty = 2) legend(&#39;topright&#39;, lty = c(1, 2), legend = c(&quot;Posterior&quot;, &quot;Prior&quot;), bty = &quot;n&quot;) } plot.distributions(0.01) plot.distributions(50) The insurance managers recommend that because this is a new premium, a vague prior distribution be used and \\(\\chi = 0.01\\). The posterior mean is \\(\\frac{10}{95.01} \\approx 0.105\\) and the 95% credible interval is round(qgamma(c(0.025, 0.975), 10, 95.01), 3) ## [1] 0.05 0.18 2.4 The Normal Distribtuion The Normal distribution is incredibly useful for modelling a wide range of natural phenomena and in its own right. We’re now going to derive posterior distributions for the normal distribution. As we’re going to see, the concepts behind deriving posterior distributions are the same as in the previous two examples. However, the algebraic accounting is a lot more taxing. Example 2.4 Known variance. Reaction times can be modeled with a normal distribution. Suppose we have a data set of the reaction times of 30 lorry drivers when they see an obstacle. The reaction times were collected in a test environment on a rolling road. The time until each lorry driver reacts (in milliseconds) is y &lt;- c(0.34, 0.47, 0.58, 0.27, 0.74, 0.44, 0.46, 0.65, 0.36, 0.55, 0.58, 0.55, 0.53, 0.56, 0.54, 0.61, 0.43, 0.52, 0.45, 0.49, 0.32, 0.33, 0.47, 0.58, 0.34, 0.60, 0.59, 0.43, 0.57, 0.34) hist(y, main = &quot;&quot;, xlab = &quot;Reaction time (ms)&quot;) mean(y) ## [1] 0.4896667 Suppose that, somehow, we know the population standard deviation is 0.01\\(ms\\) and we wish to estimate the population mean \\(\\mu\\). By Bayes’ theorem, the posterior distribution is \\[ \\pi(\\mu \\mid \\boldsymbol{y}, \\sigma^2) \\propto \\pi(\\boldsymbol{y} \\mid \\mu, \\sigma^2) \\pi(\\mu) \\] Likelihood function. We assume the each driver’s reaction time is independently and identically distributed such that \\[ y_i \\sim N(\\mu, \\sigma^2) \\] The likelihood function is therefore given by the product of the 30 normal density functions as follows \\[\\begin{align*} \\pi(\\boldsymbol{y} \\mid \\mu, \\theta^2) &amp;= \\prod_{i=1}^{30} \\frac{1}{\\sqrt{2\\pi\\sigma^2}}\\exp\\left\\{-\\frac{(y_i - \\mu)^2}{\\sigma^2}\\right\\} \\\\ &amp;= (2\\pi\\sigma^2)^{-\\frac{n}{2}}\\exp\\left\\{-\\sum_{i=1}^{30}\\frac{(y_i - \\mu)^2}{\\sigma^2}\\right\\} \\end{align*}\\] Prior distribution We suppose we have no prior beliefs about the values that \\(\\mu\\) can take. We assign a normal prior distribution to \\(\\mu \\sim N(\\mu_0, \\sigma_0^2)\\) despite it being a time. We will set \\(\\mu = 0\\) and \\(\\sigma_0^2 = 1000\\) to signify our vague prior beliefs, but, for ease, we will use the symbolic values during the derivation of the posterior distribution. We have \\[ \\pi(\\mu) = \\frac{1}{\\sqrt{2\\pi\\sigma_0^2}}\\exp\\left\\{-\\frac{1}{2\\sigma_0^2}(\\mu - \\mu_0)^2\\right\\}. \\] Posterior distribution. To derive the posterior distribution, up to proportionality, we multiply the prior distribution by the likelihood function. As the fractions out the front of both terms do not depend on \\(\\mu\\), we can ignore these. \\[\\begin{align*} \\pi(\\mu \\mid \\boldsymbol{y}, \\sigma^2) &amp;\\propto\\exp\\left\\{-\\sum_{i=1}^{30}\\frac{(y_i - \\mu)^2}{\\sigma^2}\\right\\} \\exp\\left\\{\\frac{1}{2\\sigma_0^2}(\\mu - \\mu_0)^2\\right\\} \\\\ &amp; = \\exp\\left\\{-\\sum_{i=1}^{30}\\frac{(y_i - \\mu)^2}{\\sigma^2}-\\frac{1}{2\\sigma_0^2}(\\mu - \\mu_0)^2\\right\\} \\\\ &amp; = \\exp\\left\\{-\\frac{\\sum_{i=1}^{30}y_i^2}{2\\sigma^2} + \\frac{\\mu\\sum_{i=1}^{30}y_i}{\\sigma^2} - \\frac{30\\mu^2}{2\\sigma^2} - \\frac{\\mu^2}{2\\sigma_0^2} + \\frac{\\mu\\mu_0}{\\sigma_0^2} - \\frac{\\mu_0^2}{2\\sigma_0^2}\\right\\}. \\end{align*}\\] We can drop the first and last term as they do not depend on \\(\\mu\\). With some arranging, the equation becomes \\[ \\pi(\\mu \\mid \\boldsymbol{y}, \\sigma^2) \\propto \\exp\\left\\{-\\mu^2\\left(\\frac{30}{2\\sigma^2} + \\frac{1}{2\\sigma_0^2}\\right) + \\mu\\left(\\frac{\\sum_{i=1}^{30}y_i}{\\sigma^2} + \\frac{\\mu_0}{\\sigma_0^2} \\right) \\right\\} \\] Defining \\(\\mu_1 =\\left(\\frac{\\sum_{i=1}^{30}y_i}{\\sigma^2} + \\frac{\\mu_0}{\\sigma_0^2} \\right)\\) and \\(\\sigma^2_1 = \\left(\\frac{30}{\\sigma^2} + \\frac{1}{\\sigma_0^2}\\right)^{-1}\\) tidies this up and gives \\[ \\pi(\\mu \\mid \\boldsymbol{y}, \\sigma^2) \\propto \\exp\\left\\{-\\frac{\\mu^2}{2\\sigma_1^2} + \\mu\\mu_1 \\right\\}. \\] Our last step to turning this into a distribution is completing the square. Consider the exponent term, completing the square becomes \\[ -2\\sigma_1^2\\mu^2 + \\mu\\mu_1 = -\\frac{1}{2\\sigma^2_1}\\left(\\mu - \\frac{\\mu_1}{\\sigma_1^2} \\right)^2. \\] Therefore, the posterior distribution, up to proportionality, is given by \\[ \\pi(\\mu \\mid \\boldsymbol{y}, \\sigma^2) \\propto \\exp\\left\\{-\\frac{1}{2\\sigma^2_1}\\left(\\mu - \\frac{\\mu_1}{\\sigma_1^2} \\right)^2\\right\\}, \\] and so the posterior distribution of \\(\\mu\\) is \\(\\mu \\mid \\boldsymbol{y}, \\sigma^2 \\sim N(\\mu_1, \\sigma^2_1)\\). It may help to consider the meaning of \\(\\mu_1\\) and \\(\\sigma^2_1\\). The variance of the posterior distribution can be thought of as the weighted average of the population and sample precision, where the weight is the number of data points collected. The interpretation of the posterior mean can be seen more easily by writing is as \\[ \\mu = \\sigma_1^2\\left(\\frac{30\\bar{y}}{\\sigma^2} + \\frac{\\mu_0}{\\sigma_0^2} \\right). \\] The posterior mean is partially defined through the weighted average of the population and prior means, where the weighting depends on the number of data points collected and how precise the distributions are. Now we have derived the posterior distribution, we can explore it using R. #data N &lt;- 30 #prior sigma0 &lt;- 1000 mu0 &lt;- 0 #posterior sigma1.sq &lt;- (1/(sigma0^2) + N/(0.01^2))^-1 mu1 &lt;- sigma1.sq*(sum(y)/(0.01^2) + mu0/(sigma0^2)) c(mu1, sigma1.sq) #output mean and variance ## [1] 4.896667e-01 3.333333e-06 #Create plot mu &lt;- seq(0.48, 0.5, 0.0001) posterior &lt;- dnorm(mu, mean = mu1, sd = sqrt(sigma1.sq)) plot(mu, posterior, type =&#39;l&#39;) The 95% credible interval for the population’s mean reaction time is qnorm(c(0.025, 0.975), mu1, sqrt(sigma1.sq)) ## [1] 0.4860883 0.4932451 One issue in this example is the choice of the prior distribution for \\(\\mu\\). Why are we putting a prior distribution that places weight on negative values, when we are modelling reaction times? We could argue that the resulting posterior distribution places negligible weight on invalid times. The real reason is analytical ease. The resulting posterior distribution has a nice closed form, the normal distribution. When the prior distribution induces the same function form in the posterior distribution, this is known as conjugacy. If the prior distribution \\(\\pi(\\theta)\\) has the same distributional family as the posterior distribution \\(\\pi(\\theta \\mid \\boldsymbol{y})\\), then the prior distribution is a conjugate prior distribution. 2.5 Predicition In many cases, although we are interested in estimating the model parameters, what we’re really interested in is predicting new values, whose distribution is determined by the model parameters. Definition 2.2 Suppose we observe some data \\(\\boldsymbol{y}\\) and derive the posterior distribution \\(\\pi(\\theta \\mid \\boldsymbol{y})\\). The quantity we are interested in is some future observation \\(z\\), we would like to the distribution of \\(z\\) given the observed data \\(\\boldsymbol{y}\\), \\(\\pi(z \\mid \\boldsymbol{y})\\). This distribution, known as the posterior predictive distribution of \\(z\\), must be exhibited as a mixture distribution over the possible values of \\(\\theta\\). We must write \\[ \\pi(z \\mid \\boldsymbol{y}) = \\int \\pi(z \\mid \\theta) \\pi(\\theta \\mid \\boldsymbol{y})\\, d\\theta. \\] Example 2.5 Students have to submit coursework for a particular statistical modules. However, each semester a number of students miss the deadline and hand in their coursework late. Last year, three out of 20 students handed their coursework in late. This year, the course has thirty students in. How many students can we expect to hand in their coursework late? We can model the number of students handing in late \\(X\\), using a Binomial distribution, \\(Y \\sim \\textrm{Bin}(n, \\theta)\\). As in Example 2.1, we assign a uniform prior distribution to \\(\\theta \\sim U[0, 1]\\). Given then observed data, we can derive \\(\\theta \\mid \\boldsymbol{y} \\sim Beta(4, 28)\\) (See problem sheets for derivation). Now we can derive the posterior predictive distribution of \\(Z\\), the number of students who hand in late. We model \\(Z\\) using a Binomial distribution, \\(Z \\sim \\textrm{Bin}(30, \\theta)\\). The distribution of \\(Z\\) given the observed data is \\[\\begin{align*} \\pi(z \\mid \\boldsymbol{y}) &amp;= \\int_0^1 \\pi(z \\mid \\theta) \\pi(\\theta \\mid \\boldsymbol{y})\\, d\\theta \\\\ &amp; = \\int_0^1 \\begin{pmatrix} 30 \\\\ z \\end{pmatrix} \\theta^z (1-\\theta)^{30 - z} \\frac{\\Gamma(32)}{\\Gamma(4)\\Gamma(28)}\\theta^{3}(1-\\theta)^{27}\\, d\\theta \\\\ &amp; = \\begin{pmatrix} 30 \\\\ z \\end{pmatrix}\\frac{\\Gamma(32)}{\\Gamma(4)\\Gamma(28)}\\int_0^1 \\theta^{z + 3}(1-\\theta)^{57 - z}\\, d\\theta \\\\ \\end{align*}\\] This integral is difficult to evaluate immediately. But by multiplying (and dividing outside the integral) by a constant, we can turn it into the density function of a Beta\\((5 + z, 58 - z)\\) random variable. This integrates to 1. \\[\\begin{align*} \\pi(z \\mid \\boldsymbol{y}) &amp; = \\begin{pmatrix} 30 \\\\ z \\end{pmatrix}\\frac{\\Gamma(32)}{\\Gamma(4)\\Gamma(28)}\\frac{\\Gamma(z+4)\\Gamma(58-z)}{\\Gamma(62)}\\int_0^1 \\frac{\\Gamma(62)}{\\Gamma(z+4)\\Gamma(58-z)}\\theta^{z + 3}(1-\\theta)^{57 - z}\\, d\\theta \\\\ &amp; = \\begin{pmatrix} 30 \\\\ z \\end{pmatrix}\\frac{\\Gamma(32)\\Gamma(z+4)\\Gamma(58-z)}{\\Gamma(4)\\Gamma(28)\\Gamma(62)} \\quad \\textrm{for } 0 \\leq z \\leq 30. \\end{align*}\\] This code implements the distribution beta.binom.posterior.predictive.distribution &lt;- function(z){ numerator &lt;- gamma(32)*gamma(z + 4)*gamma(58-z) denominator &lt;- gamma(4)*gamma(28)*gamma(62) output &lt;- choose(30, z)*numerator/denominator return(output) } We can check it’s correct, by seeing if it sums to one z &lt;- 0:30 ppd &lt;- beta.binom.posterior.predictive.distribution(z) sum(ppd) ## [1] 1 plot(z, ppd, xlab = &quot;z&quot;, ylab = expression(pi(z | theta))) The expected number of students who hand in late is 3.75 and there’s a 95% chance that up to 8 hand in late. z%*%ppd #expectation ## [,1] ## [1,] 3.75 cbind(z, cumsum(ppd)) #CDF ## z ## [1,] 0 0.06029453 ## [2,] 1 0.18723037 ## [3,] 2 0.35156696 ## [4,] 3 0.51889148 ## [5,] 4 0.66530044 ## [6,] 5 0.78021765 ## [7,] 6 0.86309065 ## [8,] 7 0.91880359 ## [9,] 8 0.95404202 ## [10,] 9 0.97513714 ## [11,] 10 0.98713498 ## [12,] 11 0.99363285 ## [13,] 12 0.99698773 ## [14,] 13 0.99863936 ## [15,] 14 0.99941423 ## [16,] 15 0.99976022 ## [17,] 16 0.99990696 ## [18,] 17 0.99996591 ## [19,] 18 0.99998826 ## [20,] 19 0.99999622 ## [21,] 20 0.99999887 ## [22,] 21 0.99999969 ## [23,] 22 0.99999992 ## [24,] 23 0.99999998 ## [25,] 24 1.00000000 ## [26,] 25 1.00000000 ## [27,] 26 1.00000000 ## [28,] 27 1.00000000 ## [29,] 28 1.00000000 ## [30,] 29 1.00000000 ## [31,] 30 1.00000000 2.6 Non-informative Prior Distibrutions We have seen in a few examples how the choice of prior distribution can affect that posterior distributions and the resulting conclusions. As the choice of prior distribution is subjective, it is the main criticism of Bayesian inference. A possible way around this is to use a prior distribution that reflects a lack of information about \\(\\theta\\). Definition 2.3 A non-informative prior distribution is a prior distribution that places equal weight on the every possible value of \\(\\theta\\). Example 2.6 In Example 2.1, we assigned a uniform prior distribution to the parameter \\(\\theta\\). Theorem 2.1 (Jeffrey) Given some observed data \\(\\boldsymbol{y} = \\{y_1, \\ldots, y_N\\}\\), an invariant prior distribution is \\[ \\pi(\\theta) \\propto \\sqrt{I_\\theta(\\boldsymbol{y})}, \\] where \\(I_\\theta(\\boldsymbol{y})\\) is the Fisher information for \\(\\theta\\) contained in \\(\\boldsymbol{y}\\). Jeffrey argues that if there are two ways of parameterising a model, e.g. via \\(\\theta\\) and \\(\\psi\\), then the priors on these parameters should be equivalent. In other words, the prior distribution should be invariant under sensible (one-to-one) transformations. Proof. Recall that the distribution of \\(\\psi = h(\\theta)\\), for some one-to-one function \\(h\\), is invariant to the distribution of \\(\\theta\\) if \\[ \\pi(\\psi) = \\pi(\\theta) \\left|\\frac{d\\theta}{d\\psi}\\right|. \\] Transforming the Fisher information for \\(\\psi\\) shows \\[\\begin{align*} I_\\psi(\\boldsymbol{y}) &amp;= - \\mathbb{E}\\left(\\frac{d^2\\log \\pi(\\boldsymbol{y} \\mid \\psi)}{d\\psi^2}\\right) \\\\ &amp; = \\mathbb{E}\\left(\\frac{d^2 \\log \\pi(\\boldsymbol{y} \\mid \\theta = h^{-1}(\\psi))}{d\\theta^2}\\right) \\left(\\frac{d\\theta}{d\\psi}\\right)^2 \\\\ &amp; = I_\\theta(\\boldsymbol{y})\\left(\\frac{d\\theta}{d\\psi}\\right)^2 . \\end{align*}\\] Thus \\(\\sqrt{I_\\psi(\\boldsymbol{y})} = \\sqrt{I_\\theta(\\boldsymbol{y})} \\left|\\frac{d\\theta}{d\\psi}\\right|\\) and \\(\\sqrt{I_\\psi(\\boldsymbol{y})}\\) and \\(\\sqrt{I_\\theta(\\boldsymbol{y})}\\) are invariant prior distributions. Example 2.7 In example 2.1, we modelled the number of crisps that were the incorrect weight by \\(\\theta \\sim \\textrm{Bin}(n, \\theta)\\). To construct Jeffrey’s prior distribution for \\(\\theta\\), we must first derive the Fisher’s information matrix. \\[\\begin{align*} &amp;\\pi(y \\mid \\theta) = \\begin{pmatrix} n \\\\ y \\end{pmatrix} \\theta^y (1-\\theta)^{n-y}\\\\ \\implies &amp;\\log \\pi(y \\mid \\theta) = \\log \\begin{pmatrix} n \\\\ y \\end{pmatrix} + y \\log\\theta + (n-y)\\log(1-\\theta) \\\\ \\implies &amp;\\frac{\\partial \\log \\pi(y \\mid \\theta)}{\\partial \\theta} = \\frac{y}{\\theta} - \\frac{n-y}{1-\\theta} \\\\ \\implies &amp;\\frac{\\partial^2 \\log \\pi(y \\mid \\theta)}{\\partial \\theta^2} = -\\frac{y}{\\theta^2} + \\frac{n-y}{(1-\\theta)^2} \\\\ \\implies &amp;\\mathbb{E}\\left(\\frac{\\partial \\log \\pi(y \\mid \\theta)}{\\partial \\theta}\\right) = -\\frac{\\mathbb{E}(y)}{\\theta^2} + \\frac{n-\\mathbb{E}(y)}{(1-\\theta)^2}\\\\ \\implies &amp;\\mathbb{E}\\left(\\frac{\\partial \\log \\pi(y \\mid \\theta)}{\\partial \\theta}\\right) = -\\frac{n\\theta}{\\theta^2} + \\frac{n-n\\theta}{(1-\\theta)^2}\\\\ \\implies &amp;\\mathbb{E}\\left(\\frac{\\partial \\log \\pi(y \\mid \\theta)}{\\partial \\theta}\\right) = -\\frac{n}{\\theta} + \\frac{n}{1-\\theta}\\\\ \\implies &amp;\\mathbb{E}\\left(\\frac{\\partial \\log \\pi(y \\mid \\theta)}{\\partial \\theta}\\right) = -\\frac{n}{\\theta(1-\\theta)} \\\\ \\implies &amp;I_\\theta(y) \\propto \\frac{1}{\\theta(1-\\theta)}. \\end{align*}\\] $ Hence Jeffrey’s prior is \\(\\pi(\\theta) \\propto \\theta^{-\\frac{1}{2}}(1-\\theta)^{-\\frac{1}{2}}\\). This functional dependency on \\(\\theta\\) shows that \\(\\theta \\sim \\textrm{Beta}(\\frac{1}{2}, \\frac{1}{2})\\). 2.7 Bernstein-von-Mises Theorem So far, we have considered Bayesian methods in contrast to frequentist ones. The Bernstein-von-Mises theorem is a key theorem linking the two inference methods. Theorem 2.2 (Bernstein-von-Mises) For a well-specified model \\(\\pi(\\boldsymbol{y} \\mid \\theta)\\) with a fixed number of parameters, and for a smooth prior distribution \\(\\pi(\\theta)\\) that is non-zero around the MLE \\(\\hat{\\theta}\\), then \\[ \\left|\\left| \\pi(\\theta \\mid \\boldsymbol{y}) - N\\left(\\hat{\\theta}, \\frac{I(\\hat{\\theta})^{-1}}{n}\\right) \\right|\\right|_{TV} \\rightarrow 0, \\] where \\(||p - q||_{TV}\\) is the total variation distance between distributions \\(p\\) and \\(q\\): \\[ ||p - q||_{TV} = \\frac{1}{2}\\int|\\pi(x) - q(x)|\\,dx. \\] The Berstein-von-Mises theorem says that as the number of data points approaches infinity, the posterior distribution tends to a Normal distribution centered around the MLE and variance dependent on the Fisher information. 2.8 Exercises Exercise 2.1 Suppose \\(y_1, \\ldots, y_N \\sim \\hbox{Geom}(p)\\). 1. Derive the likelihood function and then the maximum likelihood estimator for \\(p\\). 2. By letting \\(p \\sim \\hbox{Beta}(\\alpha, \\beta)\\), derive the posterior distribution for \\(p\\) given the data. 3. Compare the maximum likelihood estimate with with expectation of the posterior distribution. What values of \\(\\alpha\\) and \\(\\beta\\) result in a posterior expectation that is equal to the maximum likelihood estimate? Why is this inadvisable? Exercise 2.2 When someone is infected with a disease, it’s common to model the time they are infectious for \\(t\\) with a Gamma distribution. Suppose you observe 100 measles infections and \\(\\sum_{i=1}^{100}t_i\\) = 870 days. Based on advice from clinicians, you suppose \\(t \\sim \\hbox{Gamma}(5, \\theta)\\). Using an \\(\\theta \\sim \\hbox{Exp}(0.01)\\) prior distribution, derive the posterior distribution. What is the 95% credible interval for \\(\\theta\\)? Exercise 2.3 The density function for the Pareto distribution with scale \\(\\alpha\\) and shape \\(\\beta\\) is \\[ \\pi(x \\mid 1,\\, b) = \\frac{b}{x^{b+1}} \\] Suppose the data is given by \\(\\boldsymbol{y} = \\{y_1, \\ldots, y_N\\}\\). Place a Gamma prior distribution on \\(b\\) such that \\(b \\sim \\hbox{Gamma}(\\alpha, \\beta)\\). Derive the posterior distribution for \\(b\\) given the data. Exercise 2.4 Suppose that \\(y_i \\sim \\hbox{Binom}(n, p)\\) are iid for \\(i \\in \\{1, \\ldots, N\\}\\). By placing a Beta prior distribution on \\(p\\) such that \\(p \\sim \\hbox{Beta}(\\alpha, \\beta)\\) derive the posterior distribution. Suppose that \\(y_{N+1}\\) is then observed and is also independently drawn from the same distribution. Derive the posterior distribution by updating the previous distribution (i.e. your posterior distribution for the previous part becomes your prior distribution). Show that you obtain the same distribution if you observe all \\(N+1\\) data points at the start of the process. Exercise 2.5 Let \\(y_1, \\ldots, y_N \\sim \\hbox{Pois}(\\lambda)\\). Use Bayes’ theorem to derive the posterior distribution of \\(\\lambda\\) given the observed data. Place a Gamma prior distribution on \\(\\lambda \\sim \\hbox{Gamma}(\\alpha, \\beta)\\) and derive the form the posterior distribution takes. Discuss the effects of \\(\\alpha\\) and \\(\\beta\\) on the posterior distribution. Derive the posterior predictive distribution for a new observation \\(\\tilde{y}\\). Hint: The mass function for the negative binomial distribution with failures \\(r\\) and probability of success \\(p\\) is \\[ \\pi(x = k \\mid r, p) = \\begin{pmatrix} k + r - 1 \\\\ k \\end{pmatrix} (1-p)^k p^r. \\] Exercise 2.6 Consider the data from @{exm:normal}. Suppose the police pull over a lorry driver after they failed to stop at a red light. During a test at the side of the road, the lorry driver’s reaction time is tested and comes out as 77ms. By constructing a credible interval from the posterior predictive distribution, determine if the driver’s reaction time is suspicious. Why is this not a good comparison to make? Exercise 2.7 A distribution is said to belong to the exponential family of distributions if its density function has the form \\[ \\pi(y_i \\mid \\theta) = f(y_i)g(\\theta)\\exp\\{\\nu(\\theta)T(x)\\}. \\] Derive the likelihood function with the data \\(\\{y_1, \\ldots, y_N\\}\\). Show that the following prior distribution induces conjugacy: \\[ \\pi(\\theta) \\propto g(\\theta)^\\alpha\\exp\\{\\beta\\nu(\\theta)\\}. \\] Note: In general, distributions that belong to the exponential family have conjugate prior distributions. This is because conjugacy involve manipulation of sufficient statistics. Exercise 2.8 Let \\(y_1, \\ldots, y_N \\sim N(\\mu, \\sigma^2)\\), where \\(\\sigma^2\\) is known. Derive an invariant prior distribution (Jeffrey’s prior distribution) for \\(\\mu\\). Exercise 2.9 Consider Example @(exm:exponential) featuring the exponential distribution. Construct an invariant prior distribution for this distribution. Derive the posterior distribution using the invariant prior distribution. Using integration, discuss the validity of the prior distribution. "],["sampling.html", "Chapter 3 Sampling 3.1 Uniform random numbers 3.2 Inverse transform sampling 3.3 Rejection sampling 3.4 Markov Chain Monte Carlo 3.5 Properties of Markov Chains 3.6 Gibbs Sampler 3.7 Metropolis-Hastings 3.8 MCMC Diagnostics 3.9 Exercises", " Chapter 3 Sampling 3.1 Uniform random numbers What we won’t be doing in this module is generating true uniform random numbers. This is incredibly difficult and usually requires lots of expensive hardware. This is because computers aren’t good at being random, they require algorithmic instructions. True random number generation often uses physical methods, such as the radioactive decay of atoms, or atmospheric noise. Throughout this module, we will be using R’s built in random number generation. This is a pseudo random number generator, that has excellent random properties, but will eventually repeat. A basic random number generation method is sampling from a uniform distribution on the unit interval runif(1, 0, 1) ## [1] 0.5560342 3.2 Inverse transform sampling Suppose we want to sample from a non-uniform one-dimensional distribution. The inverse transform theorem allows us to do this using the distribution’s inverse function. Definition 3.1 The inverse function of a distribution \\(F\\), denoted \\(F^{-1}\\), is defined for all \\(u \\in (0, 1)\\) by \\[ F^{-1}(u) = \\inf\\{x \\in\\mathbb{R} : F(x) &gt; u\\}. \\] Theorem 3.1 Let \\(F :\\mathbb{R} \\rightarrow [0, 1]\\), \\(U \\sim U[0, 1]\\) and \\(Y = F^{-1}(U)\\). Then \\(Y\\) has distribution \\(F\\). Proof. We have \\[ \\pi(Y \\leq a) = \\pi(F^{-1}(U) \\leq a) = \\pi(\\inf\\{x \\in\\mathbb{R} : F(x) &gt; u\\} \\leq a). \\] Since \\(\\inf\\{x \\in\\mathbb{R} : F(x) &gt; u\\} \\leq a\\) can only hold if \\(F(a) \\geq U\\), we have \\[ \\pi(Y \\leq a) = \\pi(F(a)\\geq U) \\] As \\(U \\sim U[0, 1]\\), we have \\(\\pi(F(a)\\geq U) = F(a)\\). This theorem says that if we have a random variable \\(U \\sim U[0, 1]\\) and we want to get \\(Y \\sim F\\), then we can use \\(F^{-1}(U)\\). Viewing this theorem graphically can provide a much more intuitive understanding. Example 3.1 We would like to sample from an exponential distribution with rate 0.5. The density function is given by \\[ \\pi(y \\mid \\lambda = 0.5) = 0.5e^{0.5y}. \\] The distribution function can be derived by \\[\\begin{align*} F(y \\mid \\lambda = 0.5) &amp;= \\int_0^y 0.5e^{0.5t}\\,dt \\\\ &amp; = 1 - e^{0.5y}. \\end{align*}\\] Finally, the inverse function is given by \\[ F^{-1}(y \\mid \\lambda = 0.5) = -2\\log(1-y). \\] Therefore, if \\(U \\sim U[0, 1]\\), \\(-2\\log(1-U) \\sim \\hbox{Exp}(0.5)\\). The R code below generates a plot to show this. We can plot the CDF for most one parameter distributions straightforwardly. We can think of this theorem as allowing us to sample a point on the y-axis and then computing the quantile this corresponds to. set.seed(12345) # to reproduce y &lt;- seq(0, 10, 0.01) #Show on the interval [0, 5] f &lt;- 1 - exp(-0.5*y) #Construct the cumulative density function (CDF) plot(y, f, type =&#39;l&#39;, xlab = &quot;y&quot;, ylab= &quot;CDF&quot;) #Sample u u &lt;- runif(1) #Get the corresponding y value f.inv &lt;- -2*log(1-u) #plot segments(x0 = 0, y0 = u, x1 = f.inv, y1 = u, lty = 2) segments(x0 = f.inv, y0 = 0, x1 = f.inv, y1 = u, lty = 2) 3.3 Rejection sampling We now have a way of sampling methods where we can analytically derive the inverse distribution function. We can use this to sample from more complex densities, or simple densities more efficiently. Rejection sampling by sampling according to a density we can sample from and then rejecting or accepting that sample based on the density we’re actually interested in. Suppose we want to sample from a density \\(p\\), but can only generate samples from a density \\(q\\). If there exists some constant \\(c &gt; 0\\), such that \\(\\frac{\\pi(y)}{q(y)} \\leq c\\) for all \\(y\\), then we can generate samples from \\(p\\) by Sampling \\(Y \\sim Q\\) Sampling \\(U \\sim U[0, 1]\\) Computing \\(k = \\frac{\\pi(u)}{cq(y)}\\) Accepting \\(y\\) if \\(U &lt; k\\) and rejecting otherwise. This says draw sample a point \\(y\\) according to the density \\(q\\). Draw a vertical line at \\(y\\) from the x-axis to \\(cq(y)\\). Sample uniformly on this line. If the uniformly random sample is below \\(q\\), then accept it. Otherwise, reject it. The theory behind this is as follows. Suppose we sample some point y according to this algorithm and we want to work out its density \\(f\\), then \\[ f(y) \\propto q(y)\\pi(U &lt; k) = q(y)\\frac{\\pi(u)}{cq(y)} = \\frac{\\pi(u)}{c}. \\] Therefore, \\(f = p\\). Example 3.2 Suppose we want to sample from a distribution that has the density \\[ \\pi(y) = \\begin{cases} \\frac{3}{4}y(2-y), \\qquad y \\in [0, 2] \\\\ 0, \\qquad \\textrm{otherwise} \\end{cases}. \\] This has a maximum at \\(\\frac{3}{4}\\). We choose \\(p \\sim U[0, 1]\\) and \\(c = \\frac{3}{4}\\). The R code below shows a pictorial version of how one sample is generated. set.seed(1234) #to reproduce M &lt;- 3/4 #set M y &lt;- runif(1) #sample Y ~ Q p &lt;- 3/4*y*(2-y) #compute pi(y) k &lt;- p/(M*1) #compute k u &lt;- runif(1) #sample U ~ U[0, 1] ifelse(u &lt; k, &#39;accept&#39;, &#39;reject&#39;) #Accept if u &lt; k ## [1] &quot;reject&quot; #Create nice plot a &lt;- seq(0, 2, 0.01) b &lt;- 3/4*a*(2-a) c &lt;- M*rep(1, length(a)) plot(a, b, ylim = c(0, M), type = &#39;l&#39;) lines(a, c) segments(x0 = y, y0 = 0, x1 = y, y1 =3/4*y*(2-y) , lty = 2, lwd = 2) segments(x0 = y, y0 =3/4*y*(2-y), x1 = y, y1 = M, lty = 2, col = 2, lwd = 2) points(x = y, y = u, pch = 19) The plot also shows how the choices of \\(M\\) and \\(q\\) can make the sampling more or less efficient. In our example, the rejection space is large, meaning many of our proposed samples will be rejected. Here, we could have chosen a better \\(q\\) to minimise this space. 3.4 Markov Chain Monte Carlo Markov Chain Monte Carlo (MCMC) is a set of algorithms that sample from a posterior distribution. The combine the idea of rejection sampling, with the theory of Markov chains. Before we set out the theory of Markov chains, we’ll go through an example to show how MCMC works. Example 3.3 (Adapted from Statistical Rethinking 9) Consider an eccentric King whose kingdom consists of a ring of 10 islands. Directly north is island one, the smallest island. Going clockwise around the archipelago, next is island two, which is twice the size of island one, then island three, which is three times as large as island one. Finally, island 10 is next to island one and ten times as large. The King wanted to visit all of his islands, but spending time on each one according to its size. That is he should spend the most time on island ten and the least on island one. Being climate conscious, he also decided that flying from one side of the archipelago to the other was not allowed. Instead, he would only sail from one island to either of its neighbors. So from island one, he could reach islands two and ten. He decided to travel according to these rules: At the end of each week, he decides to stay on the same island or move to a neighboring island according to a coin toss. If it’s heads he proposes moving clockwise, and tails anti-clockwise. The island he is considering moving to is called the proposal island. To decided if he is going to move to the proposal island, the King counts out a number of shells equal to the number of size of the island. So if island five is the proposal island, he counts out five shells. He then counts out a number of stones equal to the size of the current island. If the number of seashells is greater than the number of stones, he moves to the proposed island. If the number of seashells is less than the number of stones, he takes a different strategy. He discards the number of stones equal to the number of seashells. So if there are six stone and five seashells, he ends up with 6-5=1 stone. He then places the stones and seashells into a bag a chooses one at random. If he picks a seashell, he moves to the proposed island, if he picks a shell, he stays put. This is a complex way of moving around, but it produces the required result; the time he spends on each island is proportionate to the size of the island. The code below shows an example of this over 10,000 weeks. weeks &lt;- 10000 island &lt;- numeric(weeks) current &lt;- 10 for(i in 1:weeks){ ## record current position island[i] &lt;- current #Flip a coin to move to a propose a new island proposed &lt;- current + sample(c(1, -1), size = 1) #Ensure he loops round the island if(proposed &lt; 1) proposed &lt;- 10 if(proposed &gt; 10) proposed &lt;- 1 #Decide to move p &lt;- proposed/current u &lt;- runif(1) if(u &lt; p) current &lt;- proposed } #Plot results par(mfrow = c(1, 2)) plot(island, type = &#39;l&#39;, xlab = &quot;week&quot;, ylab = &quot;island&quot;) barplot(table(island)/weeks, xlab = &quot;island&quot;, ylab = &quot;Proportion of time&quot;) We can recognise several different statistical principles in this example. The King decides to move islands dependent on where he is currently, not based on where he has been previously (Markov principle). He proposes an island to move to and accepts or rejects this decision based on some distribution (rejection principle). We are now going to describe some of the properties of Markov chains, including the Markov principle. You can watch Richard McElreath of Statistical Rethinking explain the original example in this video 3.5 Properties of Markov Chains Definition 3.2 A sequence of random variables \\(\\{Y_1, Y_2, \\ldots\\}\\) is a Markov chain if \\(p(Y_{n+1} \\mid Y_{n}, \\ldots, Y_1) = p(Y_{n+1} \\mid Y_{n})\\). That is that distribution of the next state \\(Y_{n+1}\\) only depends on the current state \\(Y_n\\) and not any previous states. Definition 3.3 The probability of transitioning from state \\(i\\) to state \\(j\\) in a Markov chain is given by \\(p_{ij}\\). The transition matrix for a Markov chain with \\(N\\) states is the \\(N \\times N\\) matrix \\(P = p_{ij}\\), where the \\(\\{i, j\\}^{th}\\) entry is probability is moving from state \\(i\\) to state \\(j\\). These two properties make Markov chains nice to work with, especially the Markov property (Definition 3.2). Two other important definitions are Definition 3.4 The period of a state \\(i\\) is given by \\(d_i = \\textrm{gcd}\\{n &gt; 0; p_{ii} &gt; 0 \\}\\). A state is aperiodic if \\(d_i = 1\\). An aperiodic chain is a chain where all states are a periodic. Definition 3.5 A Markov chain is irreducible if there exists an \\(n \\in \\mathbb{N}\\) such that \\(p(Y_n = i \\mid Y_0 = j)\\) for all pairs \\(i\\) and \\(j\\). In other words, it is possible to move from any state to any other state in a finite number of steps. We can use these definitions to start working with distributions. Suppose, the state we start at is drawn from some distribution \\(Y_1 \\sim \\boldsymbol{q}\\). Then the distributions of the second state \\(Y_2\\) depends on the distribution of \\(Y_1\\) and the transition probabilities \\[ p(Y_2 = j) = \\sum_i q_ip_{ij}. \\] If we denote the distribution of \\(Y_2 \\sim \\boldsymbol{q}^{(2)}\\), then we can write it in terms of the transition matrix \\(\\boldsymbol{q}^\\prime = \\boldsymbol{q}P\\). Now suppose we would like the distribution of \\(Y_3 \\sim \\boldsymbol{q}^{(3)}\\), thanks to the Markov property, this is the distribution for \\(Y_2\\) multiplied by the transition matrix, so \\(Y_3 \\sim qP^2\\). Inductively, \\(P_k \\sim qP^{k-1}\\). To use Markov chains to sample from distributions, we need to identify the Eigenvalues of the transition matrix. Proposition 3.1 A transition matrix \\(P\\) always has at least one eigenvalue equal to one. Proof. The columns of \\(P\\) sum to 1 as they are probability distributions. Therefore, \\(1\\) is an eigenvector. Definition 3.6 If a transition matrix \\(P\\) has a unique Eigenvalue that takes the value 1, there is a unique distribution \\(\\pi\\) such that \\[ \\pi P = \\pi. \\] This distribution \\(\\pi\\), is known as the stationary distribution. This important concept underpins MCMC methods. It says that no matter where we start our chain, we’ll eventually end up sampling states according to the distribution \\(\\pi\\). It make take a long time to reach the stationary distribution, but it will eventually get there. In order to check whether our Markov chain will converge to a stationary distributions, we need to check: the Markov chain is aperiodic, the Markov chain is irreducible, and that there exists a unique distribution \\(\\pi\\) such that \\(\\pi P = \\pi\\). Example 3.4 In Example 3.3, the King wanted to visit the islands according to how large they are. We can think of the islands as the states and the stationary distribution as \\(p(Y = i) \\propto i\\). The eccentric method the King used allowed him to construct a transition matrix for an aperiodic Markov chain. He also never visited islands regularly using this method. When designing a Markov chain, it is usually straightforward to design one that meets conditions one and two. Condition three is more difficult to prove, but for some chains it is possible to show they satisfy detailed balance. Definition 3.7 The Markov chain \\(P\\) satisfies detailed balance with respect to the distribution \\(\\pi\\) if \\[ \\pi_i p_{ij} = \\pi_j p_{ji}. \\] Theorem 3.2 (Detailed Balance) Let \\(P\\) be a transition matrix that satisfies detailed balance with respect to the distribution \\(\\pi\\). Then \\(\\pi P = \\pi\\). Proof. The \\(j^{th}\\) row of \\(\\pi P\\) is \\[\\begin{align*} \\sum_{i} \\pi_i p_{ij} &amp; = \\sum_{i} \\pi_j p_{ji} \\quad \\textrm{(detailed balance)} \\\\ &amp; = \\pi_j \\sum_{i} p_{ji} \\\\ &amp; = \\pi_j.\\qquad \\textrm{(probaility sums to 1)} \\end{align*}\\] Hence \\(\\pi P = \\pi\\). The section has shown us that we can use a Markov chain to simulate from a distribution \\(\\pi\\). All we need is for the Markov chain to be irreducible, aperiodic, and for the transition matrix to satisfy \\(\\pi P = \\pi\\). This provides the foundation theory for MCMC and allows us to sample from a posterior distribution \\(\\pi\\). What it doesn’t tell us is how to design the Markov chain, and that is what the next sections deal with. 3.6 Gibbs Sampler We’re now going to look at two algorithms to draw samples from posterior distributions. The first is the Gibbs sampler. When we can sample directly from conditional posterior distributions, we can use a Gibbs sampler. Suppose we have a distribution with parameters \\(\\{\\theta_1, \\ldots, \\theta_N\\}\\), a Gibbs sampler works as follows: Set initial values \\(\\{\\theta_1^{(0)}, \\ldots, \\theta_N^{(0)}\\}\\) Set \\(i = 1\\). Draw a value for \\(\\theta_1^{(i)}\\) from \\(\\pi(\\theta_1 \\mid \\theta_2^{(i-1)}, \\ldots, \\theta_N^{(i-1)}))\\). Draw a value for \\(\\theta_2^{(i)}\\) from \\(\\pi(\\theta_2 \\mid \\theta_1^{(i-1)}, \\theta_3^{(i-1)}, \\ldots, \\theta_N^{(i-1)}))\\). Repeat steps 3 and 4 for parameters \\(\\{\\theta_3^{(i)}, \\ldots, \\theta_N^{(i)}\\}\\). Repeat steps 3, 4, and 5, for \\(i = 2, \\ldots M\\). In code, this might look like M #number of iterations N #number of parameters theta.store &lt;- matrix(NA, N, M) theta &lt;- numeric(N) for(j in 1:M){ for(j in 1:N){ theta[i] &lt;- #sample from conditional with theta[-i] } theta.store[, j] &lt;- theta.current #store current values } The sequence \\(\\{\\theta_0^{(0)},\\ldots, \\theta_N^{(0)}\\}, \\{\\theta_0^{(1)},\\ldots, \\theta_N^{(1)}\\}, \\ldots, \\{\\theta_0^{(M)},\\ldots, \\theta_N^{(M)}\\}\\) form a Markov chain. They also form a series of samples from the posterior distribution. However, they are not iid. Example 3.5 Recall the lab in the previous chapter, where we derived the posterior distributions for the normal distribution with unknown mean and variance. The posterior distributions are given by \\[ \\mu \\mid \\boldsymbol{y}, \\sigma^2 \\sim N(\\mu_1, \\sigma^2_1) \\] where \\(\\mu_1 =\\left(\\frac{\\sum_{i=1}^{30}y_i}{\\sigma^2} + \\frac{\\mu_0}{\\sigma_0^2} \\right)\\) and \\(\\sigma^2_1 = \\left(\\frac{30}{\\sigma^2} + \\frac{1}{\\sigma_0^2}\\right)^{-1}\\), and \\[ \\sigma^2 \\mid \\boldsymbol{y}, \\mu \\sim \\textrm{inv-Gamma}\\left(\\alpha + \\frac{N}{2}, \\,\\beta + \\frac{\\sum_{i=1}^N (y_i - \\mu)^2}{2}\\right) \\] In this example, we can use a Gibbs sampler to sample from the posterior distribution. The algorithm is given by Set \\(\\mu^{(0)} = 0\\) and \\(\\sigma^{2(0)}\\) Set \\(i = 1\\). Sample \\(\\mu^{(i)} \\mid \\boldsymbol{y}, \\sigma^{2(i-1)} \\sim N(\\mu_1^{(i-1)}, {\\sigma^2}_1^{(i-1)})\\) Sample \\(\\sigma^{2(i)} \\mid \\boldsymbol{y}, \\mu^{(i)} \\sim \\textrm{inv-Gamma}\\left(\\alpha + \\frac{N}{2}, \\,\\beta + \\frac{\\sum_{i=1}^N (y_i - \\mu^{(i)})^2}{2}\\right)\\) Repeat steps 3 and 4 for \\(i = 2, \\ldots, 1000\\). 3.7 Metropolis-Hastings The second algorithm we are going to look at is the Metropolis-Hasting algorithm. This is a useful algorithm if we cannot sample directly from the posterior distribution and if the conditional distributions do not have a closed form. Suppose we want to sample from the posterior distribution \\(\\pi(\\theta \\mid \\boldsymbol{y})\\). The Metropolis-Hastings works as follows: Set the initial value \\(\\theta^{(0)}\\). Set \\(i = 1\\). Propose a new value of \\(\\theta&#39;\\) from some distribution \\(q\\) Accept \\(\\theta&#39;\\) with probability \\[ p_{\\textrm{acc}} = \\min\\left\\{\\frac{\\pi(\\theta&#39; \\mid \\boldsymbol{y})}{\\pi(\\theta \\mid \\boldsymbol{y})}\\frac{q(\\theta \\mid \\theta&#39;)}{q(\\theta&#39; \\mid \\theta)}, 1\\right\\}. \\] Repeat steps 3 to 4 for \\(i = 2, \\ldots, M\\). There are two parts to the acceptance probability in step 4. The first is the posterior ratio, similar to saying the likelihood of \\(\\theta&#39;\\) given the observed data over the likelihood of \\(\\theta\\) given the data. The second is the proposal ratio. It is similar to saying the likelihood of proposing \\(\\theta\\) given the current value \\(\\theta&#39;\\), over the likelihood of proposing \\(\\theta&#39;\\) given the current value \\(\\theta\\). In practice, we don’t need to evaluate the full posterior distribution. Recall \\[ \\pi(\\theta \\mid \\boldsymbol{y}) = \\frac{\\pi(\\boldsymbol{y} \\mid \\theta) \\pi(\\theta)}{\\pi(y)} \\] As the the denominator doesn’t depend on \\(\\theta\\), it cancels in the ration. The ratio becomes \\[ \\frac{\\pi(\\theta&#39; \\mid \\boldsymbol{y})}{\\pi(\\theta \\mid \\boldsymbol{y})} = \\frac{\\pi(\\boldsymbol{y} \\mid \\theta&#39;) \\pi(\\theta&#39;)}{\\pi(\\boldsymbol{y} \\mid \\theta) \\pi(\\theta)}. \\] This is the likelihood ratio multiplied by the prior ratio. Proposition 3.2 The Markov chain generated by the Metropolis-Hastings algorithm satisfies detailed balance with respect to the posterior distribution. Proof. Denote the current state \\(\\theta\\) and the proposed state \\(\\theta&#39;\\). We would like to show \\[ \\pi(\\theta \\mid \\boldsymbol{y}) \\pi(\\theta&#39;\\mid\\theta) = \\pi(\\theta&#39; \\mid \\boldsymbol{y}) \\pi(\\theta\\mid\\theta&#39;). \\] The density of \\(\\theta&#39;\\) given the proposed state \\(\\theta\\) is the proposal density multiplied by the acceptance probability. It is given by \\[\\begin{align*} \\pi(\\theta&#39; \\mid \\theta) &amp;= q(\\theta&#39; \\mid \\theta)p_{acc}\\\\ &amp;= q(\\theta&#39; \\mid \\theta)\\min\\left\\{\\frac{\\pi(\\theta&#39; \\mid \\boldsymbol{y})}{\\pi(\\theta&#39; \\mid \\boldsymbol{y})}\\frac{q(\\theta \\mid \\theta&#39;)}{q(\\theta&#39; \\mid \\theta)}, \\, 1\\right\\} \\\\ &amp; = \\min\\left\\{\\frac{\\pi(\\theta&#39; \\mid \\boldsymbol{y})}{\\pi(\\theta&#39; \\mid \\boldsymbol{y})}q(\\theta \\mid \\theta&#39;),\\, q(\\theta&#39; \\mid \\theta)\\right\\}. \\end{align*}\\] The left hand side of the detailed balance equation becomes \\[ \\pi(\\theta \\mid \\boldsymbol{y})\\pi(\\theta&#39; \\mid \\theta) = \\min\\{\\pi(\\theta&#39; \\mid \\boldsymbol{y})q(\\theta \\mid \\theta&#39;),\\, \\pi(\\theta \\mid \\boldsymbol{y})q(\\theta&#39; \\mid \\theta)\\}. \\] Analogously, we can show the right hand side is \\[ \\pi(\\theta&#39; \\mid \\boldsymbol{y})\\pi(\\theta \\mid \\theta&#39;) = \\min\\{\\pi(\\theta&#39; \\mid \\boldsymbol{y})q(\\theta \\mid \\theta&#39;),\\, \\pi(\\theta \\mid \\boldsymbol{y})q(\\theta&#39; \\mid \\theta)\\}. \\] Hence, \\(\\pi(\\theta \\mid \\boldsymbol{y}) \\pi(\\theta&#39;\\mid\\theta) = \\pi(\\theta&#39; \\mid \\boldsymbol{y}) \\pi(\\theta\\mid\\theta&#39;)\\) and the Markov chain satisfies detailed balance with respect to the posterior disquisition. Example 3.6 Lets think again about the reaction time example in the previous chapter.The time until each lorry driver reacts (in milliseconds) is y &lt;- c(0.34, 0.47, 0.58, 0.27, 0.74, 0.44, 0.46, 0.65, 0.36, 0.55, 0.58, 0.55, 0.53, 0.56, 0.54, 0.61, 0.43, 0.52, 0.45, 0.49, 0.32, 0.33, 0.47, 0.58, 0.34, 0.60, 0.59, 0.43, 0.57, 0.34) hist(y, main = &quot;&quot;, xlab = &quot;Reaction time (ms)&quot;) Assuming \\(y_i \\sim N(\\mu, \\sigma^2)\\), by Bayes’ theorem, the posterior distribution is \\[ \\pi(\\mu \\mid \\boldsymbol{y}, \\sigma^2) \\propto \\pi(\\boldsymbol{y} \\mid \\mu, \\sigma^2) \\pi(\\mu). \\] One of the issues, was the we assigned a normal prior distribution to the population mean parameter \\(\\mu\\). The advantage was that we could derive a posterior distribution with closed form. The disadvantage was the prior distribution assigned positive probability to impossible values of \\(\\mu\\). Now we have a tool to sample from posterior distributions that don’t have a closed form. We can instead assign an exponential prior distribution, a distribution which only has non-negative support. Letting \\(\\mu \\sim \\textrm{Exp}(0.01)\\) sets a vague prior distribution on \\(\\mu\\). The posterior distribution is therefore \\[ \\pi(\\mu \\mid \\boldsymbol{y}, \\sigma^2) \\propto \\exp\\left\\{-0.01\\mu -\\sum_{i=1}^{30}\\frac{(y_i - \\mu)^2}{\\sigma^2}\\right\\} \\] We can use the Metropolis-Hasting algorithm to sample from this posterior distribution. But how should we propose new value of \\(\\mu\\)? A common method is a Metropolis-Hastings Random Walk proposal distribution. The proposal distribution is symmetric and centered on \\(\\mu\\). The two most common methods are \\(\\mu&#39; \\mid \\mu \\sim U[\\mu - \\varepsilon, \\mu + \\varepsilon]\\) and \\(\\mu&#39; \\mid \\mu \\sim N(\\mu, \\tau^2)\\). We choose the uniform proposal distribution, with \\[ q(\\mu&#39; \\mid \\mu) = \\frac{1}{2\\varepsilon}. \\] The acceptance probability is therefore \\[ p_\\textrm{acc} = \\min\\left\\{\\frac{\\exp\\left\\{-0.01\\mu&#39; -\\sum_{i=1}^{30}\\frac{(y_i - \\mu&#39;)^2}{\\sigma^2}\\right\\} }{\\exp\\left\\{-0.01\\mu -\\sum_{i=1}^{30}\\frac{(y_i - \\mu)^2}{\\sigma^2}\\right\\} }, 1\\right\\} \\] We can implement a sampler in R as follows: #Set up elements for MCMC set.seed(123) #to reproduce n.iter &lt;- 10000 mu.store &lt;- numeric(n.iter) #Initial values mu &lt;- 1 sigma &lt;- 0.1 #known for(i in 1:n.iter){ #Propose value for mu mu.proposed &lt;- runif(1, mu - 0.01, mu + 0.01) if(mu.proposed &gt; 0){ #If mu &lt; 0 we can reject straight away #Compute (log) acceptance probability log.numerator &lt;- -0.01*mu.proposed - sum(y - mu.proposed)^2/(2*sigma^2) log.denominator &lt;- -0.01*mu - sum(y - mu)^2/(2*sigma^2) log.p.acc &lt;- log.numerator - log.denominator u &lt;- runif(1) #Accept/Reject step if(log(u) &lt; log.p.acc){ mu &lt;- mu.proposed } } #Store mu at each iteration mu.store[i] &lt;- mu } plot(mu.store, type = &#39;l&#39;, xlab = &quot;iteration&quot;, ylab = expression(mu)) We can see that after about 300 iterations, the Markov chain has converged to its stationary distribution, the posterior distribution. We can see this more clearly by removing the first 300 iterations. plot(mu.store[-c(1:300)], type = &#39;l&#39;, xlab = &quot;iteration&quot;, ylab = expression(mu)) hist(mu.store[-c(1:300)], xlab = expression(mu), main = &quot;Posterior distribution&quot;) The 95% credible interval for \\(\\mu\\) using this prior distribution is quantile(mu.store[-c(1:300)], c(0.025, 0.975)) ## 2.5% 97.5% ## 0.4832146 0.4961484 Recall that using the normal prior distribution, it was 0.486 0.493 It seems that the posterior distribution is very similar when using these two prior distributions. This is because the data is very informative. 3.8 MCMC Diagnostics When running an MCMC algorithm, it is always important to check that the Markov chain has converged and is mixing well. A key way of doing this is by looking at the trace plot. This is the plot out MCMC iterations over time. The trace plot should look like it has converged to the stationary distribution and exploring the stationary distribution efficiently. What it shouldn’t look like is a long series of small steps, or being stuck in one spot for a long time. There are two definitions that help us isolate an efficient Markov chain. Definition 3.8 The burn-in period is the number of iterations the Markov chain takes to reach the stationary distribution. Definition 3.9 The thinning parameter is the period of iterations of the Markov chain that are stored. Example 3.7 In Example @{exm:norm}, we saw a Markov chain that mixes well. We took the burn-in period to be 3,000 iterations, which was how long it took to for the chain to converge. In a Metropolis-Hasting random walk algorithm, the proposal distribution often has a large impact on how well the Markov chain mixes. The variance, or step size, of the proposal distribution can be tuned to ensure the chain mixes well. The following two examples show poorly mixing Markov chains. The first is where the step size is too big and the chain frequently gets stuck for several hundred iterations. set.seed(123) #to reproduce n.iter &lt;- 10000 mu.store &lt;- numeric(n.iter) #Initial values mu &lt;- 1 sigma &lt;- 0.1 #known for(i in 1:n.iter){ #Propose value for mu mu.proposed &lt;- runif(1, mu - 0.1, mu + 0.1) #Step size too big if(mu.proposed &gt; 0){ #If mu &lt; 0 we can reject straight away #Compute (log) acceptance probability log.numerator &lt;- -0.01*mu.proposed - sum(y - mu.proposed)^2/(2*sigma^2) log.denominator &lt;- -0.01*mu - sum(y - mu)^2/(2*sigma^2) log.p.acc &lt;- log.numerator - log.denominator u &lt;- runif(1) #Accept/Reject step if(log(u) &lt; log.p.acc){ mu &lt;- mu.proposed } } #Store mu at each iteration mu.store[i] &lt;- mu } plot(mu.store[-c(1:3000)], type = &#39;l&#39;, xlab = &quot;iteration&quot;, ylab = expression(mu)) The next is where the step size is too small. It takes a long time for the chain to converge (~50% of the run time). When the chain does converge, it is inefficient at exploring the space. set.seed(123) #to reproduce n.iter &lt;- 10000 mu.store &lt;- numeric(n.iter) #Initial values mu &lt;- 1 sigma &lt;- 0.1 #known for(i in 1:n.iter){ #Propose value for mu mu.proposed &lt;- runif(1, mu - 0.0005, mu + 0.0005) #Step size too small if(mu.proposed &gt; 0){ #If mu &lt; 0 we can reject straight away #Compute (log) acceptance probability log.numerator &lt;- -0.01*mu.proposed - sum(y - mu.proposed)^2/(2*sigma^2) log.denominator &lt;- -0.01*mu - sum(y - mu)^2/(2*sigma^2) log.p.acc &lt;- log.numerator - log.denominator u &lt;- runif(1) #Accept/Reject step if(log(u) &lt; log.p.acc){ mu &lt;- mu.proposed } } #Store mu at each iteration mu.store[i] &lt;- mu } par(mfrow = c(1, 2)) plot(mu.store, type = &#39;l&#39;, xlab = &quot;iteration&quot;, ylab = expression(mu)) plot(mu.store[-c(1:5000)], type = &#39;l&#39;, xlab = &quot;iteration&quot;, ylab = expression(mu)) 3.9 Exercises Exercise 3.1 Let \\(Y\\) have the density function \\[ \\pi(y) = \\alpha y^3 \\quad \\hbox{for } 0 \\leq y \\leq 4. \\] Compute the value of \\(\\alpha\\) that makes this a proper distribution. Derive the distribution function \\(F(y)\\). Using the inverse transform theorem, derive a function \\(g\\) such that if \\(U \\sim U[0, 1]\\), then \\(g(U)\\) has the same distribution as \\(Y\\). Solution. This exercise is about the inverse transform sampling method. As \\(\\int_0^4 \\pi(y) dy = 1\\), we have \\(\\alpha = \\frac{1}{64}\\). Introducing a dummy variable \\(x\\), we have \\[ \\int_0^y \\frac{1}{64}x^3dx = \\frac{1}{256}y^4. \\] The distribution function for \\(Y\\) is given by \\[ F(y) = \\begin{cases} 0 &amp; \\hbox{for } y &lt; 0\\\\ \\frac{1}{256}y^4 &amp; \\hbox{for } 0 \\leq &lt; y \\leq 4 \\\\ 1 \\end{cases}. \\] We have \\[ F(y) = \\frac{1}{256}y^4 \\iff F^{-1}(y) = 4y^{\\frac{1}{4}}. \\] By the inverse transform theorem, if \\(U \\sim U[0, 1]\\) then \\(4U^{\\frac{1}{4}}\\) has the same distribution as \\(Y\\). Exercise 3.2 Suppose \\(Y\\) has the density function \\[ f(y) = \\frac{1}{2\\sqrt{y}}e^{-\\sqrt{y}} \\quad \\hbox{for } y \\geq 0. \\] Using integrating by substitution, derive the distribution function \\(F(y)\\). Using the inverse transform method, construct a method for sampling from this distribution. Solution. Another exercise about the inverse transform method, but this time with a slightly more complex density function. Introducing the dummy variable \\(x\\), we need to evaluate \\[ \\int_0^y \\frac{1}{2\\sqrt{x}}e^{-\\sqrt{x}}\\,dx. \\] The easiest substitution to use is \\(u = \\sqrt{x}\\). This gives us \\(dx = 2du\\sqrt{x}\\). Substituting these into the integral gives \\[\\begin{align*} \\int_0^y \\frac{1}{2\\sqrt{x}}e^{-\\sqrt{x}}\\,dx &amp; = \\int_0^\\sqrt{y} e^{-u}\\,dx \\\\ &amp;= \\left[-e^{-u}\\right]_0^\\sqrt{y} \\\\ &amp;= 1 - e^{-\\sqrt{y}}. \\end{align*}\\] [A quicker, but less obvious way to compute the integral is to note that_ \\(\\frac{d}{dx}e^{f(x)} = f&#39;(x)e^{f(x)}\\) _.] The distribution function is therefore \\[ F(y) = \\begin{cases} 1 - e^{-\\sqrt{y}} &amp; \\hbox{for } y \\geq 0 \\\\ 0 &amp; \\hbox{otherwise} \\end{cases}. \\] Using the inverse transform method, if \\(U\\sim U[0, 1]\\) then \\(F^{-1}(U)\\) will have the same distribution as \\(Y\\). The inverse of the distribution function is \\[ F^{-1}(y) = (\\log(1-y))^2. \\] The method would be A. Sample \\(U\\sim U[0, 1]\\) B. Compute \\((\\log(1-U))^2\\) Exercise 3.3 The density function for the half-normal distribution with variance 1 is \\[ \\pi(x) = \\frac{2}{\\sqrt{2\\pi}}\\exp\\{-\\frac{1}{2}x^2\\} \\qquad \\hbox{for } x \\geq 0. \\] Using an exponential distribution with rate \\(\\lambda\\) as a proposal distribution, show that \\[ \\frac{\\pi(x)}{q(x)} = \\frac{2}{\\lambda\\sqrt{2\\pi}}\\exp\\left\\{\\lambda x - \\frac{1}{2}x^2 \\right\\}. \\] What is \\(M\\), the maximum value of this ratio? On the same plot, sketch \\(\\pi(x)\\) and \\(Mq(x)\\). Construct a rejection sampling algorithm to sample from the half normal distribution. Solution. The normal distribution is difficult to sample from, especially as the inverse of its distribution is difficult to work with. One method to generate samples is using a rejection sampling method. The density function of a exponential distribution with rate \\(\\lambda\\) is \\(q(x \\mid \\lambda) = \\lambda e^{-\\lambda x}\\). The ratio is given by \\[\\begin{align*} \\frac{\\pi(x)}{q(x)} &amp;= \\frac{\\frac{2}{\\sqrt{2\\pi}}\\exp\\{-\\frac{1}{2}x^2\\}}{\\lambda e^{-\\lambda x}} \\\\ &amp; = \\frac{2}{\\lambda\\sqrt{2\\pi}}\\exp\\left\\{\\lambda x - \\frac{1}{2}x^2\\right\\}. \\end{align*}\\] The find the maximum value of this ratio, we first need to find the value of \\(x\\) that maximises the ratio. Differentiating gives \\[ \\frac{d}{dx}\\frac{2}{\\lambda\\sqrt{2\\pi}}\\exp\\left\\{\\lambda x - \\frac{1}{2}x^2 \\right\\} = \\frac{2(\\lambda - x)}{\\lambda\\sqrt{2\\pi}}\\exp\\left\\{\\lambda x - \\frac{1}{2}x^2 \\right\\} \\] Setting this equal to 0 shows that \\(x = \\lambda\\) maximises the ratio. The maxmimum value of the ratio is thus \\[ M = \\frac{\\pi(\\lambda)}{q(\\lambda)} = \\frac{2}{\\lambda\\sqrt{2\\pi}}\\exp\\left\\{-\\frac{1}{2}\\lambda^2\\right\\} \\] The plot below shows that not only is \\(\\pi(x) \\leq Mq(x)\\), but is that \\(M\\) is the optimal value for a rejection sampling algorithm. x &lt;- seq(0, 5, 0.01) lambda &lt;- 1 #Denisties pi.x &lt;- 2/(sqrt(2*pi))*exp(-0.5*x^2) q.x &lt;- dexp(x, lambda) #M M &lt;- 2/(lambda*sqrt(2*pi))*exp(0.5*lambda^2) #Plot plot(x, pi.x, type = &#39;l&#39;, ylim = c(0, M), xaxt = &quot;n&quot;, yaxt = &quot;n&quot;, xlab = &quot;x&quot;, ylab = &quot;density&quot;) lines(x, M*q.x, lty = 2) legend(&#39;topright&#39;, c(expression(pi(x)), expression(Mq(x))), lty = c(1, 2), bty = &quot;n&quot;) The rejection sampling algorithm for the half normal distribution works as follows: A. Sample \\(x\\) from the exponential distribution. B. Sample \\(u \\sim U[0, 1]\\). C. If \\(u &lt; \\frac{\\pi(x)}{Mq(x)}\\), then accept \\(x\\) as a sample from the half normal distribution. Exercise 3.4 We are using a rejection sampling algorithm to sample from \\(f(y)\\) using the proposal distribution \\(g(y)\\). Given a proposed value \\(y\\), and let \\(A\\) be the event of sample is accepted. The probability a sample is accepted, given it takes the value \\(y\\) is \\[ A \\mid y \\sim \\hbox{Bernoulli}\\left(\\frac{f(y)}{Mg(y)}\\right). \\] Using the tower property, show \\(E(A) = \\frac{1}{M}\\). Assuming each proposal is independent, what is the distribution of the number of samples generated until one is accepted? Solution. We saw in the last question that we derived the optimal value of the constant \\(M\\). This exercise is about computing the efficiency of a rejection sampling algorithm, which depends on \\(M\\). The efficiency is the expected number of proposals generated until one is accepted. Let \\(A\\) be the event a proposal is accepted, we would like We have \\(A \\mid y \\sim \\hbox{Bernoulli}\\left(\\frac{f(y)}{Mg(y)}\\right)\\). By the tower property \\[\\begin{align*} E(A) &amp; = E(E(A\\mid y)) \\\\ &amp; = E\\left(\\frac{f(y)}{Mg(y)}\\right) \\\\ &amp; = \\int \\frac{f(y)}{Mg(y)} g(y) dy \\\\ &amp; = \\frac{1}{M}\\int f(y) dy \\\\ &amp; = \\frac{1}{M}. \\end{align*}\\] The number of events until a success is modelled by the geometric distribution. The number of samples proposed before one is accepted is distributed geometrically with mean \\(\\frac{1}{M}\\). The smaller the value of \\(M\\), the more efficient the sampler. Exercise 3.5 Alice wants to construct a Markov Chain to sample numbers from one to six. She chooses an initial number at random. She flips a coin and decides to stay with that number if it’s a head, and move to a different number if it’s a tails. If she chooses to move number she flips the coin again. If it’s heads, she moves to a number one larger than she is now, if it’s tails she moves to a number one smaller than she is now. Once she reaches one or six, she stops. Draw a state space diagram for this chain. Is Alice’s Markov chain aperiodic and irreducible? Bob comes up with a similar Markov chain. Like Alice, he chooses an initial number at random and flips a coin to decide if he should keep that number of move to a different one. However, his next step differs from Alice’s. If he chooses to move number he flips the coin again. If it’s heads, he moves to a number two larger than he is now, if it’s tails he moves to a number two smaller than he is now. He also treats the numbers like a circle, where if he is on six, he can move to four or two. Likewise, if he is on one, he can move to five or three. Draw a state space diagram for this chain. Is Bob’s Markov chain aperiodic and irreducible? Solution. The state space diagram for Alice and Bob’s Markov chains are: Neither Alice nor Bob have constructed Markov chains that are aperiodic and irreducible. In Alice’s chain, states one and six are absorbing states – if Alice ends up with one of these numbers, she is never going to choose another number. This means states one and six have period one. As Alice’s chain has absorbing states, it isn’t irreducible either. For example, it isn’t possible to get from state six to two in a finite (or any) number of steps. As Bob has introduce a mechanism to loop round the numbers, his chain is aperiodic. However, it isn’t irreducible. Moving up and down two numbers means that he is restricted to the even or odd numbers. If he starts on an even number, he is never going to reach an odd number. Exercise 3.6 You observe \\(N\\) data points \\(\\{y_1, \\ldots, y_N\\} \\sim N(\\mu, sigma^2)\\). Place a normal prior distribution on the mean parameter \\(\\mu\\) and inverse-gamma prior distribution \\(\\sigma^2\\) to derive the posterior distributions \\(\\pi(\\mu, \\sigma^2 \\mid \\boldsymbol{y})\\). Solution. Using the prior distributions \\[ \\mu \\sim N(\\mu_0, \\sigma_0^2), \\qquad $\\sigma^2 \\sim \\hbox{inv}-\\Gamma(\\alpha, \\beta)$ \\] gives the posterior distribution …. The full conditional distributions are \\[ \\mu \\mid \\sigma^2, \\boldsymbol{y} \\sim N(\\mu_1, \\sigma_1^2), \\qquad \\sigma^2 \\mid \\mu,\\boldsymbol{y} \\sim \\hbox{inv}-\\Gamma(\\alpha_1, \\beta_1). \\] A good MCMC algorithm could look like this: Set \\(\\mu^{(1)} = 0\\), \\(\\sigma^{2(0)} = 1\\) and \\(i = 1\\). Sample \\(\\mu^{(i)} \\mid \\sigma^{2(i-1)}, \\boldsymbol{y} \\sim N(\\mu_1, \\sigma_1^2)\\). Sample \\(\\sigma^{2(i)} \\mid \\mu^{(i)}, \\boldsymbol{y} \\sim \\hbox{inv}-\\Gamma(\\alpha_1, \\beta_1)\\). Repeat steps 2 and 3 for a given number of iterations. Check the trace plots to ensure the Markov chain has converged and mixed well. Exercise 3.7 In the lectures, we looked at Metropolis-Hastings Random Walk algorithms. Another algorithm is a Metropolis-Hastings Independence Sampler. In an independence sampler, the proposal distribution does not depend on the current values, that is \\[ q(y&#39;\\mid y) = q(y&#39;). \\] Let \\(y_1, \\ldots, y_N \\sim N(\\mu, \\sigma^2)\\), where \\(\\sigma^2\\) is know. Show the posterior distribution has no closed form when the prior distribution \\(\\mu \\sim \\Gamma(\\alpha, \\beta)\\) is used. Suppose you are constructing an MCMC algorithm to sample from this distribution. Denote the current value of the Markov chain \\(\\mu\\). Given a proposal \\(\\mu&#39; \\sim N(0, 5^2)\\) proposal distribution, derive the acceptance probability. Solution. This question is about independence samplers. They are typically very good or very bad at sampling from the posterior distribution. The likelihood function is given by \\[ \\pi(\\boldsymbol{y} \\mid \\mu, \\sigma^2) \\propto \\exp\\left\\{-\\frac{1}{2\\sigma^2}\\sum_{i=1}^N (y_i - \\mu)^2 \\right\\}. \\] The prior distribution is \\(\\pi(\\mu) \\propto \\mu^{\\alpha-1}\\exp\\{-beta\\mu\\}\\). The posterior distribution is the product of these and given by \\[ \\pi(\\mu \\mid \\boldsymbol{y}, \\sigma^2) \\propto \\mu^{\\alpha-1} \\exp\\left\\{-\\frac{1}{2\\sigma^2}\\sum_{i=1}^N (y_i - \\mu)^2 - \\beta\\mu\\right\\}. \\] The acceptance probability is \\[ p_{acc} = \\frac{\\pi(\\mu&#39;\\mid \\boldsymbol{y}, \\sigma^2)}{\\pi(\\mu&#39;\\mid \\boldsymbol{y}, \\sigma^2)} \\frac{\\pi(\\mu)}{\\pi(\\mu&#39;)}. \\] Substituting the proportional densities in yields \\[ p_{acc} = \\exp\\left\\{-\\frac{1}{2\\sigma^2}\\sum_{i=1}^N (y_i - \\mu&#39;)^2 + \\frac{1}{2\\sigma^2}\\sum_{i=1}^N (y_i - \\mu)^2 -\\frac{1}{50}\\mu^2 + \\frac{1}{50}{\\mu&#39;}^2 \\right\\}. \\] "],["advanced-computation.html", "Chapter 4 Advanced computation 4.1 Heiracichal Models 4.2 Prior Ellicitation 4.3 Data Augmentation", " Chapter 4 Advanced computation Now we have the tools of Bayesian inference and methods to sample from complex posterior distributions, we can start to look at more advanced methods and models. This chapter is split into three distinct parts, each showing a different method in Bayesian inference. 4.1 Heiracichal Models 4.2 Prior Ellicitation 4.3 Data Augmentation "]]
