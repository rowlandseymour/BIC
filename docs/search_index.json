[["sampling.html", "Chapter 4 Sampling 4.1 Uniform random numbers 4.2 Inverse transform sampling 4.3 Rejection sampling 4.4 Markov Chain Monte Carlo 4.5 Properties of Markov Chains 4.6 Gibbs Sampler 4.7 Metropolis-Hastings 4.8 MCMC Diagnostics", " Chapter 4 Sampling 4.1 Uniform random numbers What we won’t be doing in this module is generating true uniform random numbers. This is incredibly difficult and usually requires lots of expensive hardware. This is because computers aren’t good at being random, they require algorithmic instructions. True random number generation often uses physical methods, such as the radioactive decay of atoms, or atmospheric noise. Throughout this module, we will be using R’s built in random number generation. This is a pseudo random number generator, that has excellent random properties, but will eventually repeat. A basic random number generation method is sampling from a uniform distribution on the unit interval runif(1, 0, 1) ## [1] 0.722065 4.2 Inverse transform sampling Suppose we want to sample from a non-uniform one-dimensional distribution. The inverse transform theorem allows us to do this using the distribution’s inverse function. Definition 4.1 The inverse function of a distribution \\(F\\), denoted \\(F^{-1}\\), is defined for all \\(u \\in (0, 1)\\) by \\[ F^{-1}(u) = \\inf\\{x \\in\\mathbb{R} : F(x) &gt; u\\}. \\] Theorem 4.1 Let \\(F :\\mathbb{R} \\rightarrow [0, 1]\\), \\(U \\sim U[0, 1]\\) and \\(Y = F^{-1}(U)\\). Then \\(Y\\) has distribution \\(F\\). Proof. We have \\[ \\pi(Y \\leq a) = \\pi(F^{-1}(U) \\leq a) = \\pi(\\inf\\{x \\in\\mathbb{R} : F(x) &gt; u\\} \\leq a). \\] Since \\(\\inf\\{x \\in\\mathbb{R} : F(x) &gt; u\\} \\leq a\\) can only hold if \\(F(a) \\geq U\\), we have \\[ \\pi(Y \\leq a) = \\pi(F(a)\\geq U) \\] As \\(U \\sim U[0, 1]\\), we have \\(\\pi(F(a)\\geq U) = F(a)\\). This theorem says that if we have a random variable \\(U \\sim U[0, 1]\\) and we want to get \\(Y \\sim F\\), then we can use \\(F^{-1}(U)\\). Viewing this theorem graphically can provide a much more intuitive understanding. Example 4.1 We would like to sample from an exponential distribution with rate 0.5. The likelihood function is given by \\[ \\pi(y \\mid \\lambda = 0.5) = 0.5e^{0.5y}. \\] The distribution function can be derived by \\[\\begin{align*} F(y \\mid \\lambda = 0.5) &amp;= \\int_0^y 0.5e^{0.5t}\\,dt \\\\ &amp; = 1 - e^{0.5y}. \\end{align*}\\] Finally, the inverse function is given by \\[ F^{-1}(y \\mid \\lambda = 0.5) = -2\\log(1-y). \\] Therefore, if \\(U \\sim U[0, 1]\\), \\(-2\\log(1-U) \\sim \\hbox{Exp}(0.5)\\). The R code below generates a plot to show this. We can plot the CDF for most one parameter distributions straightforwardly. We can think of this theorem as allowing us to sample a point on the y-axis and then computing the quantile this corresponds to. set.seed(12345) # to reproduce y &lt;- seq(0, 10, 0.01) #Show on the interval [0, 5] f &lt;- 1 - exp(-0.5*y) #Construct the cumulative density function (CDF) plot(y, f, type =&#39;l&#39;, xlab = &quot;y&quot;, ylab= &quot;CDF&quot;) #Sample u u &lt;- runif(1) #Get the corresponding y value f.inv &lt;- -2*log(1-u) #plot segments(x0 = 0, y0 = u, x1 = f.inv, y1 = u, lty = 2) segments(x0 = f.inv, y0 = 0, x1 = f.inv, y1 = u, lty = 2) 4.3 Rejection sampling We now have a way of sampling methods where we can analytically derive the inverse distribution function. We can use this to sample from more complex densities, or simple densities more efficiently. Rejection sampling by sampling according to a density we can sample from and then rejecting or accepting that sample based on the density we’re actually interested in. Suppose we want to sample from a density \\(p\\), but can only generate samples from a density \\(q\\). If there exists some constant \\(c &gt; 0\\), such that \\(\\frac{\\pi(y)}{q(y)} \\leq c\\) for all \\(y\\), then we can generate samples from \\(p\\) by Sampling \\(Y \\sim Q\\) Sampling \\(U \\sim U[0, 1]\\) Computing \\(k = \\frac{\\pi(u)}{cq(y)}\\) Accepting \\(y\\) if \\(U &lt; k\\) and rejecting otherwise. This says draw sample a point \\(y\\) according to the density \\(q\\). Draw a vertical line at \\(y\\) from the x-axis to \\(cq(y)\\). Sample uniformly on this line. If the uniformly random sample is below \\(q\\), then accept it. Otherwise, reject it. The theory behind this is as follows. Suppose we sample some point y according to this algorithm and we want to work out its density \\(f\\), then \\[ f(y) \\propto q(y)\\pi(U &lt; k) = q(y)\\frac{\\pi(u)}{cq(y)} = \\frac{\\pi(u)}{c}. \\] Therefore, \\(f = p\\). Example 4.2 Suppose we want to sample from a distribution that has the density \\[ \\pi(y) = \\begin{cases} \\frac{3}{4}y(2-y), \\qquad y \\in [0, 2] \\\\ 0, \\qquad \\textrm{otherwise} \\end{cases}. \\] This has a maximum at \\(\\frac{3}{4}\\). We choose \\(p \\sim U[0, 1]\\) and \\(c = \\frac{3}{4}\\). The R code below shows a pictorial version of how one sample is generated. set.seed(1234) #to reproduce M &lt;- 3/4 #set M y &lt;- runif(1) #sample Y ~ Q p &lt;- 3/4*y*(2-y) #compute pi(y) k &lt;- p/(M*1) #compute k u &lt;- runif(1) #sample U ~ U[0, 1] ifelse(u &lt; k, &#39;accept&#39;, &#39;reject&#39;) #Accept if u &lt; k ## [1] &quot;reject&quot; #Create nice plot a &lt;- seq(0, 2, 0.01) b &lt;- 3/4*a*(2-a) c &lt;- M*rep(1, length(a)) plot(a, b, ylim = c(0, M), type = &#39;l&#39;) lines(a, c) segments(x0 = y, y0 = 0, x1 = y, y1 =3/4*y*(2-y) , lty = 2, lwd = 2) segments(x0 = y, y0 =3/4*y*(2-y), x1 = y, y1 = M, lty = 2, col = 2, lwd = 2) points(x = y, y = u, pch = 19) The plot also shows how the choices of \\(M\\) and \\(q\\) can make the sampling more or less efficient. In our example, the rejection space is large, meaning many of our proposed samples will be rejected. Here, we could have chosen a better \\(q\\) to minimise this space. 4.4 Markov Chain Monte Carlo Markov Chain Monte Carlo (MCMC) is a set of algorithms that sample from a posterior distribution. The combine the idea of rejection sampling, with the theory of Markov chains. Before we set out the theory of Markov chains, we’ll go through an example to show how MCMC works. Example 4.3 (Adapted from Statistical Rethinking 9) Consider an eccentric King whose kingdom consists of a ring of 10 islands. Directly north is island one, the smallest island. Going clockwise around the archipelago, next is island two, which is twice the size of island one, then island three, which is three times as large as island one. Finally, island 10 is next to island one and ten times as large. The King wanted to visit all of his islands, but spending time on each one according to its size. That is he should spend the most time on island ten and the least on island one. Being climate conscious, he also decided that flying from one side of the archipelago to the other was not allowed. Instead, he would only sail from one island to either of its neighbors. So from island one, he could reach islands two and ten. He decided to travel according to these rules: At the end of each week, he decides to stay on the same island or move to a neighboring island according to a coin toss. If it’s heads he proposes moving clockwise, and tails anti-clockwise. The island he is considering moving to is called the proposal island. To decided if he is going to move to the proposal island, the King counts out a number of shells equal to the number of size of the island. So if island five is the proposal island, he counts out five shells. He then counts out a number of stones equal to the size of the current island. If the number of seashells is greater than the number of stones, he moves to the proposed island. If the number of seashells is less than the number of stones, he takes a different strategy. He discards the number of stones equal to the number of seashells. So if there are six stone and five seashells, he ends up with 6-5=1 stone. He then places the stones and seashells into a bag a chooses one at random. If he picks a seashell, he moves to the proposed island, if he picks a shell, he stays put. This is a complex way of moving around, but it produces the required result; the time he spends on each island is proportionate to the size of the island. The code below shows an example of this over 10,000 weeks. weeks &lt;- 10000 island &lt;- numeric(weeks) current &lt;- 10 for(i in 1:weeks){ ## record current position island[i] &lt;- current #Flip a coin to move to a propose a new island proposed &lt;- current + sample(c(1, -1), size = 1) #Ensure he loops round the island if(proposed &lt; 1) proposed &lt;- 10 if(proposed &gt; 10) proposed &lt;- 1 #Decide to move p &lt;- proposed/current u &lt;- runif(1) if(u &lt; p) current &lt;- proposed } #Plot results par(mfrow = c(1, 2)) plot(island, type = &#39;l&#39;, xlab = &quot;week&quot;, ylab = &quot;island&quot;) barplot(table(island)/weeks, xlab = &quot;island&quot;, ylab = &quot;Proportion of time&quot;) We can recognise several different statistical principles in this example. The King decides to move islands dependent on where he is currently, not based on where he has been previously (Markov principle). He proposes an island to move to and accepts or rejects this decision based on some distribution (rejection principle). We are now going to describe some of the properties of Markov chains, including the Markov principle. You can watch Richard McElreath of Statistical Rethinking explain the original example in this video 4.5 Properties of Markov Chains Definition 4.2 A sequence of random variables \\(\\{Y_1, Y_2, \\ldots\\}\\) is a Markov chain if \\(p(Y_{n+1} \\mid Y_{n}, \\ldots, Y_1) = p(Y_{n+1} \\mid Y_{n})\\). That is that distribution of the next state \\(Y_{n+1}\\) only depends on the current state \\(Y_n\\) and not any previous states. Definition 4.3 The probability of transitioning from state \\(i\\) to state \\(j\\) in a Markov chain is given by \\(p_{ij}\\). The transition matrix for a Markov chain with \\(N\\) states is the \\(N \\times N\\) matrix \\(P = p_{ij}\\), where the \\(\\{i, j\\}^{th}\\) entry is probability is moving from state \\(i\\) to state \\(j\\). These two properties make Markov chains nice to work with, especially the Markov property (Definition 4.2). Two other important definitions are Definition 4.4 The period of a state \\(i\\) is given by \\(d_i = \\textrm{gcd}\\{n &gt; 0; p_{ii} &gt; 0 \\}\\). A state is aperiodic if \\(d_i = 1\\). An aperiodic chain is a chain where all states are a periodic. Definition 4.5 A Markov chain is irreducible if there exists an \\(n \\in \\mathbb{N}\\) such that \\(p(Y_n = i \\mid Y_0 = j)\\) for all pairs \\(i\\) and \\(j\\). In other words, it is possible to move from any state to any other state in a finite number of steps. We can use these definitions to start working with distributions. Suppose, the state we start at is drawn from some distribution \\(Y_1 \\sim \\boldsymbol{q}\\). Then the distributions of the second state \\(Y_2\\) depends on the distribution of \\(Y_1\\) and the transition probabilities \\[ p(Y_2 = j) = \\sum_i q_ip_{ij}. \\] If we denote the distribution of \\(Y_2 \\sim \\boldsymbol{q}^{(2)}\\), then we can write it in terms of the transition matrix \\(\\boldsymbol{q}^\\prime = \\boldsymbol{q}P\\). Now suppose we would like the distribution of \\(Y_3 \\sim \\boldsymbol{q}^{(3)}\\), thanks to the Markov property, this is the distribution for \\(Y_2\\) multiplied by the transition matrix, so \\(Y_3 \\sim qP^2\\). Inductively, \\(P_k \\sim qP^{k-1}\\). To use Markov chains to sample from distributions, we need to identify the Eigenvalues of the transition matrix. Proposition 4.1 A transition matrix \\(P\\) always has at least one eigenvalue equal to one. Proof. The columns of \\(P\\) sum to 1 as they are probability distributions. Therefore, \\(1\\) is an eigenvector. ::: {.definition} If a transition matrix \\(P\\) has a unique Eigenvalue that takes the value 1, there is a unique distribution \\(\\pi\\) such that \\[ \\pi P = \\pi. \\] This distribution \\(\\pi\\), is known as the stationary distribution. ::: This important concept underpins MCMC methods. It says that no matter where we start our chain, we’ll eventually end up sampling states according to the distribution \\(\\pi\\). It make take a long time to reach the stationary distribution, but it will eventually get there. In order to check whether our Markov chain will converge to a stationary distributions, we need to check: the Markov chain is aperiodic, the Markov chain is irreducible, and that there exists a unique distribution \\(\\pi\\) such that \\(\\pi P = \\pi\\). Example 4.4 In Example 4.3, the King wanted to visit the islands according to how large they are. We can think of the islands as the states and the stationary distribution as \\(p(Y = i) \\propto i\\). The eccentric method the King used allowed him to construct a transition matrix for an aperiodic Markov chain. He also never visited islands regularly using this method. When designing a Markov chain, it is usually straightforward to design one that meets conditions one and two. Condition three is more difficult to prove, but for some chains it is possible to show they satisfy detailed balance. Definition 4.6 The Markov chain \\(P\\) satisfies detailed balance with respect to the distribution \\(\\pi\\) if \\[ \\pi_i p_{ij} = \\pi_j p_{ji}. \\] Theorem 4.2 (Detailed Balance) Let \\(P\\) be a transition matrix that satisfies detailed balance with respect to the distribution \\(\\pi\\). Then \\(\\pi P = \\pi\\). Proof. The \\(j^{th}\\) row of \\(\\pi P\\) is \\[\\begin{align*} \\sum_{i} \\pi_i p_{ij} &amp; = \\sum_{i} \\pi_j p_{ji} \\quad \\textrm{(detailed balance)} \\\\ &amp; = \\pi_j \\sum_{i} p_{ji} \\\\ &amp; = \\pi_j.\\qquad \\textrm{(probaility sums to 1)} \\end{align*}\\] Hence \\(\\pi P = \\pi\\). The section has shown us that we can use a Markov chain to simulate from a distribution \\(\\pi\\). All we need is for the Markov chain to be irreducible, aperiodic, and for the transition matrix to satisfy \\(\\pi P = \\pi\\). This provides the foundation theory for MCMC and allows us to sample from a posterior distribution \\(\\pi\\). What it doesn’t tell us is how to design the Markov chain, and that is what the next sections deal with. 4.6 Gibbs Sampler We’re now going to look at two algorithms to draw samples from posterior distributions. The first is the Gibbs sampler. When we can sample directly from conditional posterior distributions, we can use a Gibbs sampler. Suppose we have a distribution with parameters \\(\\{\\theta_1, \\ldots, \\theta_N\\}\\), a Gibbs sampler works as follows: Set initial values \\(\\{\\theta_1^{(0)}, \\ldots, \\theta_N^{(0)}\\}\\) Set \\(i = 1\\). Draw a value for \\(\\theta_1^{(i)}\\) from \\(\\pi(\\theta_1 \\mid \\theta_2^{(i-1)}, \\ldots, \\theta_N^{(i-1)}))\\). Draw a value for \\(\\theta_2^{(i)}\\) from \\(\\pi(\\theta_2 \\mid \\theta_1^{(i-1)}, \\theta_3^{(i-1)}, \\ldots, \\theta_N^{(i-1)}))\\). Repeat steps 3 and 4 for parameters \\(\\{\\theta_3^{(i)}, \\ldots, \\theta_N^{(i)}\\}\\). Repeat steps 3, 4, and 5, for \\(i = 2, \\ldots M\\). In code, this might look like M #number of iterations N #number of parameters theta.store &lt;- matrix(NA, N, M) theta &lt;- numeric(N) for(j in 1:M){ for(j in 1:N){ theta[i] &lt;- #sample from conditional with theta[-i] } theta.store[, j] &lt;- theta.current #store current values } The sequence \\(\\{\\theta_0^{(0)},\\ldots, \\theta_N^{(0)}\\}, \\{\\theta_0^{(1)},\\ldots, \\theta_N^{(1)}\\}, \\ldots, \\{\\theta_0^{(M)},\\ldots, \\theta_N^{(M)}\\}\\) form a Markov chain. They also form a series of samples from the posterior distribution. However, they are not iid. Example 4.5 Recall the lab in the previous chapter, where we derived the posterior distributions for the normal distribution with unknown mean and variance. The posterior distributions are given by \\[ \\mu \\mid \\boldsymbol{y}, \\sigma^2 \\sim N(\\mu_1, \\sigma^2_1) \\] where \\(\\mu_1 =\\left(\\frac{\\sum_{i=1}^{30}y_i}{\\sigma^2} + \\frac{\\mu_0}{\\sigma_0^2} \\right)\\) and \\(\\sigma^2_1 = \\left(\\frac{30}{\\sigma^2} + \\frac{1}{\\sigma_0^2}\\right)^{-1}\\), and \\[ \\sigma^2 \\mid \\boldsymbol{y}, \\mu \\sim \\textrm{inv-Gamma}\\left(\\alpha + \\frac{N}{2}, \\,\\beta + \\frac{\\sum_{i=1}^N (y_i - \\mu)^2}{2}\\right) \\] In this example, we can use a Gibbs sampler to sample from the posterior distribution. The algorithm is given by Set \\(\\mu^{(0)} = 0\\) and \\(\\sigma^{2(0)}\\) Set \\(i = 1\\). Sample \\(\\mu^{(i)} \\mid \\boldsymbol{y}, \\sigma^{2(i-1)} \\sim N(\\mu_1^{(i-1)}, {\\sigma^2}_1^{(i-1)})\\) Sample \\(\\sigma^{2(i)} \\mid \\boldsymbol{y}, \\mu^{(i)} \\sim \\textrm{inv-Gamma}\\left(\\alpha + \\frac{N}{2}, \\,\\beta + \\frac{\\sum_{i=1}^N (y_i - \\mu^{(i)})^2}{2}\\right)\\) Repeat steps 3 and 4 for \\(i = 2, \\ldots, 1000\\). 4.7 Metropolis-Hastings The second algorithm we are going to look at is the Metropolis-Hasting algorithm. This is a useful algorithm if we cannot sample directly from the posterior distribution and if the conditional distributions do not have a closed form. Suppose we want to sample from the posterior distribution \\(\\pi(\\theta \\mid \\boldsymbol{y})\\). The Metropolis-Hastings works as follows: Set the initial value \\(\\theta^{(0)}\\). Set \\(i = 1\\). Propose a new value of \\(\\theta&#39;\\) from some distribution \\(q\\) Accept \\(\\theta&#39;\\) with probability \\[ p_{\\textrm{acc}} = \\min\\left\\{\\frac{\\pi(\\theta&#39; \\mid \\boldsymbol{y})}{\\pi(\\theta \\mid \\boldsymbol{y})}\\frac{q(\\theta \\mid \\theta&#39;)}{q(\\theta&#39; \\mid \\theta)}, 1\\right\\}. \\] Repeat steps 3 to 4 for \\(i = 2, \\ldots, M\\). There are two parts to the acceptance probability in step 4. The first is the posterior ratio, similar to saying the likelihood of \\(\\theta&#39;\\) given the observed data over the likelihood of \\(\\theta\\) given the data. The second is the proposal ratio. It is similar to saying the likelihood of proposing \\(\\theta\\) given the current value \\(\\theta&#39;\\), over the likelihood of proposing \\(\\theta&#39;\\) given the current value \\(\\theta\\). In practice, we don’t need to evaluate the full posterior distribution. Recall \\[ \\pi(\\theta \\mid \\boldsymbol{y}) = \\frac{\\pi(\\boldsymbol{y} \\mid \\theta) \\pi(\\theta)}{\\pi(y)} \\] As the the denominator doesn’t depend on \\(\\theta\\), it cancels in the ration. The ratio becomes \\[ \\frac{\\pi(\\theta&#39; \\mid \\boldsymbol{y})}{\\pi(\\theta \\mid \\boldsymbol{y})} = \\frac{\\pi(\\boldsymbol{y} \\mid \\theta&#39;) \\pi(\\theta&#39;)}{\\pi(\\boldsymbol{y} \\mid \\theta) \\pi(\\theta)}. \\] This is the likelihood ratio multiplied by the prior ratio. Proposition 4.2 The Markov chain generated by the Metropolis-Hastings algorithm satisfies detailed balance with respect to the posterior distribution. Proof. Denote the current state \\(\\theta\\) and the proposed state \\(\\theta&#39;\\). We would like to show \\[ \\pi(\\theta \\mid \\boldsymbol{y}) \\pi(\\theta&#39;\\mid\\theta) = \\pi(\\theta&#39; \\mid \\boldsymbol{y}) \\pi(\\theta\\mid\\theta&#39;). \\] The density of \\(\\theta&#39;\\) given the proposed state \\(\\theta\\) is the proposal density multiplied by the acceptance probability. It is given by \\[\\begin{align*} \\pi(\\theta&#39; \\mid \\theta) &amp;= q(\\theta&#39; \\mid \\theta)p_{acc}\\\\ &amp;= q(\\theta&#39; \\mid \\theta)\\min\\left\\{\\frac{\\pi(\\theta&#39; \\mid \\boldsymbol{y})}{\\pi(\\theta&#39; \\mid \\boldsymbol{y})}\\frac{q(\\theta \\mid \\theta&#39;)}{q(\\theta&#39; \\mid \\theta)}, \\, 1\\right\\} \\\\ &amp; = \\min\\left\\{\\frac{\\pi(\\theta&#39; \\mid \\boldsymbol{y})}{\\pi(\\theta&#39; \\mid \\boldsymbol{y})}q(\\theta \\mid \\theta&#39;),\\, q(\\theta&#39; \\mid \\theta)\\right\\}. \\end{align*}\\] The left hand side of the detailed balance equation becomes \\[ \\pi(\\theta \\mid \\boldsymbol{y})\\pi(\\theta&#39; \\mid \\theta) = \\min\\{\\pi(\\theta&#39; \\mid \\boldsymbol{y})q(\\theta \\mid \\theta&#39;),\\, \\pi(\\theta \\mid \\boldsymbol{y})q(\\theta&#39; \\mid \\theta)\\}. \\] Analogously, we can show the right hand side is \\[ \\pi(\\theta&#39; \\mid \\boldsymbol{y})\\pi(\\theta \\mid \\theta&#39;) = \\min\\{\\pi(\\theta&#39; \\mid \\boldsymbol{y})q(\\theta \\mid \\theta&#39;),\\, \\pi(\\theta \\mid \\boldsymbol{y})q(\\theta&#39; \\mid \\theta)\\}. \\] Hence, \\(\\pi(\\theta \\mid \\boldsymbol{y}) \\pi(\\theta&#39;\\mid\\theta) = \\pi(\\theta&#39; \\mid \\boldsymbol{y}) \\pi(\\theta\\mid\\theta&#39;)\\) and the Markov chain satisfies detailed balance with respect to the posterior disquisition. Example 4.6 Lets think again about the reaction time example in the previous chapter.The time until each lorry driver reacts (in milliseconds) is y &lt;- c(0.34, 0.47, 0.58, 0.27, 0.74, 0.44, 0.46, 0.65, 0.36, 0.55, 0.58, 0.55, 0.53, 0.56, 0.54, 0.61, 0.43, 0.52, 0.45, 0.49, 0.32, 0.33, 0.47, 0.58, 0.34, 0.60, 0.59, 0.43, 0.57, 0.34) hist(y, main = &quot;&quot;, xlab = &quot;Reaction time (ms)&quot;) Assuming \\(y_i \\sim N(\\mu, \\sigma^2)\\), by Bayes’ theorem, the posterior distribution is \\[ \\pi(\\mu \\mid \\boldsymbol{y}, \\sigma^2) \\propto \\pi(\\boldsymbol{y} \\mid \\mu, \\sigma^2) \\pi(\\mu). \\] One of the issues, was the we assigned a normal prior distribution to the population mean parameter \\(\\mu\\). The advantage was that we could derive a posterior distribution with closed form. The disadvantage was the prior distribution assigned positive probability to impossible values of \\(\\mu\\). Now we have a tool to sample from posterior distributions that don’t have a closed form. We can instead assign an exponential prior distribution, a distribution which only has non-negative support. Letting \\(\\mu \\sim \\textrm{Exp}(0.01)\\) sets a vague prior distribution on \\(\\mu\\). The posterior distribution is therefore \\[ \\pi(\\mu \\mid \\boldsymbol{y}, \\sigma^2) \\propto \\exp\\left\\{-0.01\\mu -\\sum_{i=1}^{30}\\frac{(y_i - \\mu)^2}{\\sigma^2}\\right\\} \\] We can use the Metropolis-Hasting algorithm to sample from this posterior distribution. But how should we propose new value of \\(\\mu\\)? A common method is a Metropolis-Hastings Random Walk proposal distribution. The proposal distribution is symmetric and centered on \\(\\mu\\). The two most common methods are \\(\\mu&#39; \\mid \\mu \\sim U[\\mu - \\varepsilon, \\mu + \\varepsilon]\\) and \\(\\mu&#39; \\mid \\mu \\sim N(\\mu, \\tau^2)\\). We choose the uniform proposal distribution, with \\[ q(\\mu&#39; \\mid \\mu) = \\frac{1}{2\\varepsilon}. \\] The acceptance probability is therefore \\[ p_\\textrm{acc} = \\min\\left\\{\\frac{\\exp\\left\\{-0.01\\mu&#39; -\\sum_{i=1}^{30}\\frac{(y_i - \\mu&#39;)^2}{\\sigma^2}\\right\\} }{\\exp\\left\\{-0.01\\mu -\\sum_{i=1}^{30}\\frac{(y_i - \\mu)^2}{\\sigma^2}\\right\\} }, 1\\right\\} \\] We can implement a sampler in R as follows: #Set up elements for MCMC set.seed(123) #to reproduce n.iter &lt;- 10000 mu.store &lt;- numeric(n.iter) #Initial values mu &lt;- 1 sigma &lt;- 0.1 #known for(i in 1:n.iter){ #Propose value for mu mu.proposed &lt;- runif(1, mu - 0.01, mu + 0.01) if(mu.proposed &gt; 0){ #If mu &lt; 0 we can reject straight away #Compute (log) acceptance probability log.numerator &lt;- -0.01*mu.proposed - sum(y - mu.proposed)^2/(2*sigma^2) log.denominator &lt;- -0.01*mu - sum(y - mu)^2/(2*sigma^2) log.p.acc &lt;- log.numerator - log.denominator u &lt;- runif(1) #Accept/Reject step if(log(u) &lt; log.p.acc){ mu &lt;- mu.proposed } } #Store mu at each iteration mu.store[i] &lt;- mu } plot(mu.store, type = &#39;l&#39;, xlab = &quot;iteration&quot;, ylab = expression(mu)) We can see that after about 300 iterations, the Markov chain has converged to its stationary distribution, the posterior distribution. We can see this more clearly by removing the first 300 iterations. plot(mu.store[-c(1:300)], type = &#39;l&#39;, xlab = &quot;iteration&quot;, ylab = expression(mu)) hist(mu.store[-c(1:300)], xlab = expression(mu), main = &quot;Posterior distribution&quot;) The 95% credible interval for \\(\\mu\\) using this prior distribution is quantile(mu.store[-c(1:300)], c(0.025, 0.975)) ## 2.5% 97.5% ## 0.4832146 0.4961484 Recall that using the normal prior distribution, it was 0.486 0.493 It seems that the posterior distribution is very similar when using these two prior distributions. This is because the data is very informative. 4.8 MCMC Diagnostics When running an MCMC algorithm, it is always important to check that the Markov chain has converged and is mixing well. A key way of doing this is by looking at the trace plot. This is the plot out MCMC iterations over time. The trace plot should look like it has converged to the stationary distribution and exploring the stationary distribution efficiently. What it shouldn’t look like is a long series of small steps, or being stuck in one spot for a long time. There are two definitions that help us isolate an efficient Markov chain. Definition 4.7 The burn-in period is the number of iterations the Markov chain takes to reach the stationary distribution. Definition 4.8 The thinning parameter is the period of iterations of the Markov chain that are stored. Example 4.7 In Example @{exm:norm}, we saw a Markov chain that mixes well. We took the burn-in period to be 3,000 iterations, which was how long it took to for the chain to converge. In a Metropolis-Hasting random walk algorithm, the proposal distribution often has a large impact on how well the Markov chain mixes. The variance, or step size, of the proposal distribution can be tuned to ensure the chain mixes well. The following two examples show poorly mixing Markov chains. The first is where the step size is too big and the chain frequently gets stuck for several hundred iterations. set.seed(123) #to reproduce n.iter &lt;- 10000 mu.store &lt;- numeric(n.iter) #Initial values mu &lt;- 1 sigma &lt;- 0.1 #known for(i in 1:n.iter){ #Propose value for mu mu.proposed &lt;- runif(1, mu - 0.1, mu + 0.1) #Step size too big if(mu.proposed &gt; 0){ #If mu &lt; 0 we can reject straight away #Compute (log) acceptance probability log.numerator &lt;- -0.01*mu.proposed - sum(y - mu.proposed)^2/(2*sigma^2) log.denominator &lt;- -0.01*mu - sum(y - mu)^2/(2*sigma^2) log.p.acc &lt;- log.numerator - log.denominator u &lt;- runif(1) #Accept/Reject step if(log(u) &lt; log.p.acc){ mu &lt;- mu.proposed } } #Store mu at each iteration mu.store[i] &lt;- mu } plot(mu.store[-c(1:3000)], type = &#39;l&#39;, xlab = &quot;iteration&quot;, ylab = expression(mu)) The next is where the step size is too small. It takes a long time for the chain to converge (~50% of the run time). When the chain does converge, it is inefficient at exploring the space. set.seed(123) #to reproduce n.iter &lt;- 10000 mu.store &lt;- numeric(n.iter) #Initial values mu &lt;- 1 sigma &lt;- 0.1 #known for(i in 1:n.iter){ #Propose value for mu mu.proposed &lt;- runif(1, mu - 0.0005, mu + 0.0005) #Step size too big if(mu.proposed &gt; 0){ #If mu &lt; 0 we can reject straight away #Compute (log) acceptance probability log.numerator &lt;- -0.01*mu.proposed - sum(y - mu.proposed)^2/(2*sigma^2) log.denominator &lt;- -0.01*mu - sum(y - mu)^2/(2*sigma^2) log.p.acc &lt;- log.numerator - log.denominator u &lt;- runif(1) #Accept/Reject step if(log(u) &lt; log.p.acc){ mu &lt;- mu.proposed } } #Store mu at each iteration mu.store[i] &lt;- mu } par(mfrow = c(1, 2)) plot(mu.store, type = &#39;l&#39;, xlab = &quot;iteration&quot;, ylab = expression(mu)) plot(mu.store[-c(1:5000)], type = &#39;l&#39;, xlab = &quot;iteration&quot;, ylab = expression(mu)) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
