qvcalc::qvcalc(btability)
btability <- data.frame(btability)
qvcalc::qvcalc(btability)
help(qvcalc)
btability <- BradleyTerry2::BTabilities(BTmoutcome) #Ability estimates and their standard errors
qvcalc::qvcalc(btability)
set.seed(1234)   #to reproduce
scaling.c <- 3/2         #set c
y <- runif(1, 0, 2)    #sample Y ~ Q
p <- 3/4*y*(2-y) #compute pi(y)
k <- p/(scaling.c*1/2)     #compute k
u <- runif(1)    #sample U ~ U[0, 1]
ifelse(u < k, 'accept', 'reject') #Accept if  u < k
#Create nice plot
a <- seq(0, 2, 0.01)
b <- 3/4*a*(2-a)
scaling.c  <- scaling.c*rep(1, length(a))
plot(a, b, ylim = c(0, scaling.c), type = 'l')
set.seed(1234)   #to reproduce
scaling.c <- 3/2         #set c
scaling.c
y <- runif(1, 0, 2)    #sample Y ~ Q
p <- 3/4*y*(2-y) #compute pi(y)
k <- p/(scaling.c*1/2)     #compute k
u <- runif(1)    #sample U ~ U[0, 1]
ifelse(u < k, 'accept', 'reject') #Accept if  u < k
#Create nice plot
a <- seq(0, 2, 0.01)
b <- 3/4*a*(2-a)
scaling.c  <- scaling.c*rep(1, length(a))
plot(a, b, ylim = c(0, scaling.c), type = 'l')
ylim
c
9
scaling.x
scaling.c
x <- seq(0, 6, 0.01)
y <- dgamma(x, 3, 2)
sacling.c <- 2^3/gamma(3)*4*exp(-4)
q <- dexp(x, 1)
q
x <- seq(0, 6, 0.01)
scaling.
y <- dgamma(x, 3, 2)
scaling.c <- 2^3/gamma(3)*4*exp(-4)
q <- dexp(x, 1)
plot(x, y, type = 'l')
scaling.c <- 2^3/gamma(3)*4*exp(-4)
x <- seq(0, 6, 0.01)
y <- dgamma(x, 3, 2)
scaling.c <- 2^3/gamma(3)*4*exp(-4)
q <- dexp(x, 1)
plot(x, y, type = 'l')
lines(x, q/scaling.c, col = 2, lty = 2)
lines(x, q*scaling.c, col = 2, lty = 2)
z <- 2^3/gamma(3)*x^2*exp(-2*x)
plot(x, z, type = 'l')
x[which.max(x)]
x[which.max(z)]
which.max(z)
max(z)
z <- 2^3/gamma(3)*x^2*exp(-*x)
plot(x, z, type = 'l')
z <- 2^3/gamma(3)*x^2*exp(-x)
plot(x, z, type = 'l')
x[which.max(z)]
max(z)
scaling.q
scaling.c
2^3/gamma(3)*4*exp(-4)
scaling.c <- 2^3/gamma(3)*4*exp(-2)
q <- dexp(x, 1)
plot(x, y, type = 'l')
lines(x, q*scaling.c, col = 2, lty = 2)
x <- seq(-5, 5, 0.01)
y <- 1/(pi(1 + x^2))
plot(x, y, type = 'l')
y <- 1/(pi*(1 + x^2))
plot(x, y, type = 'l')
x <- rep(20, 0.3)
z
x
x <- rexp(20, 0.3)
x
sum(z)
sum(x)
lambda <- 0.5
n.iter <- 10000
lambda.store <- numeric(n.iter)
sum.x <- 36.6
for(i in 1:n.iter){
lambda.prop <- rnorm(1, lambda, 0.1)
#Check lambda \in [0, 1]
if(lambda.prop > 0 & lambda.prop < 1){
log.p.acc <- (N + alpha - 1)*log(lambda.prop/lambda) +
(beta - 1)*log((1-lambda.prop)/(1-lambda)) +
(lambda - lambda.prop)*sum.x
if(log(runif(1)) < log.p.acc)
lambda <- lambda.prop
}
lambda.store[i] <- lambda
}
lambda <- 0.5
n.iter <- 10000
lambda.store <- numeric(n.iter)
sum.x <- 36.6
N <- 20
for(i in 1:n.iter){
lambda.prop <- rnorm(1, lambda, 0.1)
#Check lambda \in [0, 1]
if(lambda.prop > 0 & lambda.prop < 1){
log.p.acc <- (N + alpha - 1)*log(lambda.prop/lambda) +
(beta - 1)*log((1-lambda.prop)/(1-lambda)) +
(lambda - lambda.prop)*sum.x
if(log(runif(1)) < log.p.acc)
lambda <- lambda.prop
}
lambda.store[i] <- lambda
}
lambda <- 0.5
n.iter <- 10000
lambda.store <- numeric(n.iter)
sum.x <- 36.6
N <- 20
alpha <- 1
beta <- 1
for(i in 1:n.iter){
lambda.prop <- rnorm(1, lambda, 0.1)
#Check lambda \in [0, 1]
if(lambda.prop > 0 & lambda.prop < 1){
log.p.acc <- (N + alpha - 1)*log(lambda.prop/lambda) +
(beta - 1)*log((1-lambda.prop)/(1-lambda)) +
(lambda - lambda.prop)*sum.x
if(log(runif(1)) < log.p.acc)
lambda <- lambda.prop
}
lambda.store[i] <- lambda
}
plot(lambda.store, type = 'l', xlab = "iteration", ylab = expression(lambda))
lambda <- 0.5
n.iter <- 10000
lambda.store <- numeric(n.iter)
sum.x <- 36.6
N <- 20
alpha <- 1
beta <- 1
for(i in 1:n.iter){
lambda.prop <- rnorm(1, lambda, 0.1)
#Check lambda \in [0, 1]
if(lambda.prop > 0 & lambda.prop < 1){
log.p.acc <- (N + alpha - 1)*log(lambda.prop/lambda) +
(beta - 1)*log((1-lambda.prop)/(1-lambda)) +
(lambda - lambda.prop)*sum.x
if(log(runif(1)) < log.p.acc)
lambda <- lambda.prop
}
lambda.store[i] <- lambda
}
plot(lambda.store, type = 'l', xlab = "iteration", ylab = expression(lambda))
abline(h=0.3, col = 2) #the value I used to simulate the data
x <- rexp(20, 0.3)
lambda <- 0.5
n.iter <- 10000
lambda.store <- numeric(n.iter)
sum.x <- 36.6
N <- 20
alpha <- 1
beta <- 1
for(i in 1:n.iter){
lambda.prop <- rnorm(1, lambda, 0.1)
#Check lambda \in [0, 1]
if(lambda.prop > 0 & lambda.prop < 1){
log.p.acc <- (N + alpha - 1)*log(lambda.prop/lambda) +
(beta - 1)*log((1-lambda.prop)/(1-lambda)) +
(lambda - lambda.prop)*sum.x
if(log(runif(1)) < log.p.acc)
lambda <- lambda.prop
}
lambda.store[i] <- lambda
}
plot(lambda.store, type = 'l', xlab = "iteration", ylab = expression(lambda))
abline(h=0.3, col = 2) #the value I used to simulate the data
x <- rexp(20, 0.3)
lambda <- 0.5
n.iter <- 10000
lambda.store <- numeric(n.iter)
sum.x <- 36.6
N <- 20
alpha <- 1
beta <- 1
for(i in 1:n.iter){
lambda.prop <- rnorm(1, lambda, 0.1)
#Check lambda \in [0, 1]
if(lambda.prop > 0 & lambda.prop < 1){
log.p.acc <- (N + alpha - 1)*log(lambda.prop/lambda) +
(beta - 1)*log((1-lambda.prop)/(1-lambda)) -
(lambda - lambda.prop)*sum.x
if(log(runif(1)) < log.p.acc)
lambda <- lambda.prop
}
lambda.store[i] <- lambda
}
plot(lambda.store, type = 'l', xlab = "iteration", ylab = expression(lambda))
abline(h=0.3, col = 2) #the value I used to simulate the data
x <- rexp(20, 0.3)
lambda <- 0.5
n.iter <- 10000
lambda.store <- numeric(n.iter)
sum.x <- 36.6
N <- 20
alpha <- 1
beta <- 1
for(i in 1:n.iter){
lambda.prop <- rnorm(1, lambda, 0.1)
#Check lambda \in [0, 1]
if(lambda.prop > 0 & lambda.prop < 1){
log.p.acc <- (N + alpha - 1)*log(lambda.prop/lambda) +
(beta - 1)*log((1-lambda.prop)/(1-lambda)) +
(lambda - lambda.prop)*sum.x
if(log(runif(1)) < log.p.acc)
lambda <- lambda.prop
}
lambda.store[i] <- lambda
}
plot(lambda.store, type = 'l', xlab = "iteration", ylab = expression(lambda))
abline(h=0.3, col = 2) #the value I used to simulate the data
sum(x)
lambda <- 0.5
n.iter <- 10000
lambda.store <- numeric(n.iter)
sum.x <- 67.6
N <- 20
alpha <- 1
beta <- 1
for(i in 1:n.iter){
lambda.prop <- rnorm(1, lambda, 0.1)
#Check lambda \in [0, 1]
if(lambda.prop > 0 & lambda.prop < 1){
log.p.acc <- (N + alpha - 1)*log(lambda.prop/lambda) +
(beta - 1)*log((1-lambda.prop)/(1-lambda)) +
(lambda - lambda.prop)*sum.x
if(log(runif(1)) < log.p.acc)
lambda <- lambda.prop
}
lambda.store[i] <- lambda
}
plot(lambda.store, type = 'l', xlab = "iteration", ylab = expression(lambda))
abline(h=0.3, col = 2) #the value I used to simulate the data
#Plot posterior density
hist(lambda.store, prob = TRUE, xlab = expression(lambda), main = "Posterior density")
abline(v=0.3, col = 2) #the value I used to simulate the data
mean(lambda.store)
# Set Up MCMC Algorithm ---------------------------------------------------
n.iter <- 10000
lambda.store <- numeric(n.iter) #Store value of Markov chain at end of every iteration
gamma.store <- numeric(n.iter) #Store value of Markov chain at end of every iteration
# Run MCMC Algorithm ------------------------------------------------------
for(i in 2:n.iter){
#Store current value of Markov Chain
lambda.store[i] <- rgamma(10, 95 + gamma.store[i-1])
gamma.store[i]  <- rexp(0.01 + lambda.store[i])
}
warnings()
x <- rexp(20, 0.3)
# Set Up MCMC Algorithm ---------------------------------------------------
n.iter <- 10000
lambda.store <- numeric(n.iter) #Store value of Markov chain at end of every iteration
gamma.store <- numeric(n.iter) #Store value of Markov chain at end of every iteration
# Run MCMC Algorithm ------------------------------------------------------
for(i in 2:n.iter){
#Store current value of Markov Chain
lambda.store[i] <- rgamma(1, 10, 95 + gamma.store[i-1])
gamma.store[i]  <- rexp(1, 0.01 + lambda.store[i])
}
#Plot trace plot (Markov chain values)
plot(lambda.store, type = 'l', xlab = "iteration", ylab = expression(lambda))
plot(gamma.store, type = 'l', xlab = "iteration", ylab = expression(gamma))
#Plot posterior density
hist(lambda.store, prob = TRUE, xlab = expression(lambda), main = "Posterior density")
#Plot posterior density
hist(lambda.store, prob = TRUE, xlab = expression(lambda), main = "Posterior density")
mean(lambda.store) #posterior mean
quantile(lambda.store, c(0.025, 0.975)) #95% CI
hist(gamma.store, prob = TRUE, xlab = expression(lambda), main = "Posterior density")
mean(gamma.store) #posterior mean
quantile(gamma.store, c(0.025, 0.975)) #95% CI
plot(lambda.store, gamma.store)
plot(lambda.store, log(gamma.store))
cor(lambda.store, log(gamma.store))
cor(lambda.store, gamma.store)
plot(lambda.store, (gamma.store))
#Function that evaluates Pareto loglikelihood
log.likelihood <- function(x, beta){
log.value <- length(x)*log(beta) - (beta + 1)*sum(log(x))
return(log.value)
}
# MCMC Sampler ------------------------------------------------------------
#Initialise Values
x <- c(1.019844, 1.043574, 1.360953, 1.049228, 1.491926, 1.192943, 1.323738, 1.262572, 2.034768, 1.451654)
n.iter <- 10000 #number of iterations
beta.current <- 2 #initial value for beta
beta.store <- numeric(n.iter) #empty vecotr to store beta at each iteration
#Run MCMC For Loop
for(i in 1:n.iter){
#Propose prop value for beta
beta.prop <- rnorm(1, beta.current, 0.01)
#Compute current and prop loglikelihood
loglike.prop     <- log.likelihood(x, beta.prop)
loglike.current <- log.likelihood(x, beta.current)
#Compute Log acceptance probability
log.p.acc <- loglike.prop - loglike.current +
dgamma(beta.prop, 1, 0.01, log = TRUE) - dgamma(beta.current, 1, 0.01, log = TRUE)
#Accept/Reject
u <- runif(1)
if(log(u) < log.p.acc){
beta.current <- beta.prop
}
#Store Current Value
beta.store[i] <- beta.current
}
#Plot trace plots
plot(beta.store, type = 'l')
#Investigate posterior
hist(beta.store, freq = FALSE, main = "", xlab = expression(beta))
quantile(beta.store, c(0.025, 0.975))
#Function that evaluates Pareto loglikelihood
log.likelihood <- function(x, beta){
log.value <- length(x)*log(beta) - (beta + 1)*sum(log(x))
return(log.value)
}
# MCMC Sampler ------------------------------------------------------------
#Initialise Values
x <- c(1.019844, 1.043574, 1.360953, 1.049228, 1.491926, 1.192943, 1.323738, 1.262572, 2.034768, 1.451654)
n.iter <- 10000 #number of iterations
beta.current <- 2 #initial value for beta
beta.store <- numeric(n.iter) #empty vecotr to store beta at each iteration
#Run MCMC For Loop
for(i in 1:n.iter){
#Propose prop value for beta
beta.prop <- rnorm(1, beta.current, 0.1)
#Compute current and prop loglikelihood
loglike.prop     <- log.likelihood(x, beta.prop)
loglike.current <- log.likelihood(x, beta.current)
#Compute Log acceptance probability
log.p.acc <- loglike.prop - loglike.current +
dgamma(beta.prop, 1, 0.01, log = TRUE) - dgamma(beta.current, 1, 0.01, log = TRUE)
#Accept/Reject
u <- runif(1)
if(log(u) < log.p.acc){
beta.current <- beta.prop
}
#Store Current Value
beta.store[i] <- beta.current
}
#Plot trace plots
plot(beta.store, type = 'l')
#Investigate posterior
hist(beta.store, freq = FALSE, main = "", xlab = expression(beta))
quantile(beta.store, c(0.025, 0.975))
#Function that evaluates Pareto loglikelihood
log.likelihood <- function(x, beta){
log.value <- length(x)*log(beta) - (beta + 1)*sum(log(x))
return(log.value)
}
# MCMC Sampler ------------------------------------------------------------
#Initialise Values
x <- c(1.019844, 1.043574, 1.360953, 1.049228, 1.491926, 1.192943, 1.323738, 1.262572, 2.034768, 1.451654)
n.iter <- 10000 #number of iterations
beta.current <- 2 #initial value for beta
beta.store <- numeric(n.iter) #empty vecotr to store beta at each iteration
#Run MCMC For Loop
for(i in 1:n.iter){
#Propose prop value for beta
beta.prop <- rnorm(1, beta.current, 0.2)
#Compute current and prop loglikelihood
loglike.prop     <- log.likelihood(x, beta.prop)
loglike.current <- log.likelihood(x, beta.current)
#Compute Log acceptance probability
log.p.acc <- loglike.prop - loglike.current +
dgamma(beta.prop, 1, 0.01, log = TRUE) - dgamma(beta.current, 1, 0.01, log = TRUE)
#Accept/Reject
u <- runif(1)
if(log(u) < log.p.acc){
beta.current <- beta.prop
}
#Store Current Value
beta.store[i] <- beta.current
}
#Plot trace plots
plot(beta.store, type = 'l')
#Function that evaluates Pareto loglikelihood
log.likelihood <- function(x, beta){
log.value <- length(x)*log(beta) - (beta + 1)*sum(log(x))
return(log.value)
}
# MCMC Sampler ------------------------------------------------------------
#Initialise Values
x <- c(1.019844, 1.043574, 1.360953, 1.049228, 1.491926, 1.192943, 1.323738, 1.262572, 2.034768, 1.451654)
n.iter <- 10000 #number of iterations
beta.current <- 2 #initial value for beta
beta.store <- numeric(n.iter) #empty vecotr to store beta at each iteration
#Run MCMC For Loop
for(i in 1:n.iter){
#Propose prop value for beta
beta.prop <- rnorm(1, beta.current, 0.3)
#Compute current and prop loglikelihood
loglike.prop     <- log.likelihood(x, beta.prop)
loglike.current <- log.likelihood(x, beta.current)
#Compute Log acceptance probability
log.p.acc <- loglike.prop - loglike.current +
dgamma(beta.prop, 1, 0.01, log = TRUE) - dgamma(beta.current, 1, 0.01, log = TRUE)
#Accept/Reject
u <- runif(1)
if(log(u) < log.p.acc){
beta.current <- beta.prop
}
#Store Current Value
beta.store[i] <- beta.current
}
#Plot trace plots
plot(beta.store, type = 'l')
#Function that evaluates Pareto loglikelihood
log.likelihood <- function(x, beta){
log.value <- length(x)*log(beta) - (beta + 1)*sum(log(x))
return(log.value)
}
# MCMC Sampler ------------------------------------------------------------
#Initialise Values
x <- c(1.019844, 1.043574, 1.360953, 1.049228, 1.491926, 1.192943, 1.323738, 1.262572, 2.034768, 1.451654)
n.iter <- 10000 #number of iterations
beta.current <- 2 #initial value for beta
beta.store <- numeric(n.iter) #empty vecotr to store beta at each iteration
#Run MCMC For Loop
for(i in 1:n.iter){
#Propose prop value for beta
beta.prop <- rnorm(1, beta.current, 0.5)
#Compute current and prop loglikelihood
loglike.prop     <- log.likelihood(x, beta.prop)
loglike.current <- log.likelihood(x, beta.current)
#Compute Log acceptance probability
log.p.acc <- loglike.prop - loglike.current +
dgamma(beta.prop, 1, 0.01, log = TRUE) - dgamma(beta.current, 1, 0.01, log = TRUE)
#Accept/Reject
u <- runif(1)
if(log(u) < log.p.acc){
beta.current <- beta.prop
}
#Store Current Value
beta.store[i] <- beta.current
}
#Plot trace plots
plot(beta.store, type = 'l')
#Function that evaluates Pareto loglikelihood
log.likelihood <- function(x, beta){
log.value <- length(x)*log(beta) - (beta + 1)*sum(log(x))
return(log.value)
}
# MCMC Sampler ------------------------------------------------------------
#Initialise Values
x <- c(1.019844, 1.043574, 1.360953, 1.049228, 1.491926, 1.192943, 1.323738, 1.262572, 2.034768, 1.451654)
n.iter <- 10000 #number of iterations
beta.current <- 2 #initial value for beta
beta.store <- numeric(n.iter) #empty vecotr to store beta at each iteration
#Run MCMC For Loop
for(i in 1:n.iter){
#Propose prop value for beta
beta.prop <- rnorm(1, beta.current, 0.6)
#Compute current and prop loglikelihood
loglike.prop     <- log.likelihood(x, beta.prop)
loglike.current <- log.likelihood(x, beta.current)
#Compute Log acceptance probability
log.p.acc <- loglike.prop - loglike.current +
dgamma(beta.prop, 1, 0.01, log = TRUE) - dgamma(beta.current, 1, 0.01, log = TRUE)
#Accept/Reject
u <- runif(1)
if(log(u) < log.p.acc){
beta.current <- beta.prop
}
#Store Current Value
beta.store[i] <- beta.current
}
#Function that evaluates Pareto loglikelihood
log.likelihood <- function(x, beta){
log.value <- length(x)*log(beta) - (beta + 1)*sum(log(x))
return(log.value)
}
# MCMC Sampler ------------------------------------------------------------
#Initialise Values
x <- c(1.019844, 1.043574, 1.360953, 1.049228, 1.491926, 1.192943, 1.323738, 1.262572, 2.034768, 1.451654)
n.iter <- 10000 #number of iterations
beta.current <- 2 #initial value for beta
beta.store <- numeric(n.iter) #empty vecotr to store beta at each iteration
#Run MCMC For Loop
for(i in 1:n.iter){
#Propose prop value for beta
beta.prop <- rnorm(1, beta.current, 0.6)
#Compute current and prop loglikelihood
loglike.prop     <- log.likelihood(x, beta.prop)
loglike.current <- log.likelihood(x, beta.current)
#Compute Log acceptance probability
log.p.acc <- loglike.prop - loglike.current +
dgamma(beta.prop, 1, 0.01, log = TRUE) - dgamma(beta.current, 1, 0.01, log = TRUE)
#Accept/Reject
u <- runif(1)
if(log(u) < log.p.acc){
beta.current <- beta.prop
}
#Store Current Value
beta.store[i] <- beta.current
}
#Plot trace plots
plot(beta.store, type = 'l')
