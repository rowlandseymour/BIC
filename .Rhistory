lambda.store <- numeric(n.iter)
epsilon <- 60
for(i in 1:n.iter){
lambda <-rbeta(1, 3, 1)
x.star <- rexp(5, lambda)
d <- sum((x-x.star)^2)
if(d < epsilon){
lambda.store[i] <- lambda
} else{
lambda.store[i] <- NA
}
}
#Get number of reject samples
sum(is.na(lambda.store))
#Plot Approximate Posterior
hist(lambda.store, freq = FALSE, xlab = expression(sigma^2), main = "")
mean(lambda.store, na.rm = TRUE)
quantile(lambda.store, c(0.025, 0.975), na.rm = TRUE)
x <- c(2.6863422, 8.8468112, 8.8781831, 0.2712696, 1.8902442)
n.iter <- 50000
lambda.store <- numeric(n.iter)
epsilon <- 70
for(i in 1:n.iter){
lambda <-rbeta(1, 3, 1)
x.star <- rexp(5, lambda)
d <- sum((x-x.star)^2)
if(d < epsilon){
lambda.store[i] <- lambda
} else{
lambda.store[i] <- NA
}
}
#Get number of reject samples
sum(is.na(lambda.store))
#Plot Approximate Posterior
hist(lambda.store, freq = FALSE, xlab = expression(sigma^2), main = "")
mean(lambda.store, na.rm = TRUE)
quantile(lambda.store, c(0.025, 0.975), na.rm = TRUE)
abs.function <- function(epsilon){
for(i in 1:n.iter){
lambda <-rbeta(1, 3, 1)
x.star <- rexp(5, lambda)
d <- sum((x-x.star)^2)
if(d < epsilon){
lambda.store[i] <- lambda
} else{
lambda.store[i] <- NA
}
}
output(mean(lambda.store))
}
mean(x)
1/mean(x)
abc.function <- function(epsilon){
for(i in 1:n.iter){
lambda <-rbeta(1, 1, 3)
x.star <- rexp(5, lambda)
d <- sum((x-x.star)^2)
if(d < epsilon){
lambda.store[i] <- lambda
} else{
lambda.store[i] <- NA
}
}
output(mean(lambda.store))
}
abc.lambda <- numeric(51)
for(i in 50:100){
abc.lambda[i-49] <- abc.function(i)
}
x <- c(2.6863422, 8.8468112, 8.8781831, 0.2712696, 1.8902442)
n.iter <- 50000
lambda.store <- numeric(n.iter)
epsilon <- 70
abc.function <- function(epsilon){
for(i in 1:n.iter){
lambda <-rbeta(1, 1, 3)
x.star <- rexp(5, lambda)
d <- sum((x-x.star)^2)
if(d < epsilon){
lambda.store[i] <- lambda
} else{
lambda.store[i] <- NA
}
}
return(mean(lambda.store))
}
abc.lambda <- numeric(51)
for(i in 50:100){
abc.lambda[i-49] <- abc.function(i)
}
plot(abc.lambda)
abc.lambda
abc.function(i)
for(i in 1:n.iter){
lambda <-rbeta(1, 1, 3)
x.star <- rexp(5, lambda)
d <- sum((x-x.star)^2)
if(d < epsilon){
lambda.store[i] <- lambda
} else{
lambda.store[i] <- NA
}
}
epsilon <- 70
abc.function <- function(epsilon){
x <- c(2.6863422, 8.8468112, 8.8781831, 0.2712696, 1.8902442)
n.iter <- 50000
lambda.store <- numeric(n.iter)
for(i in 1:n.iter){
lambda <-rbeta(1, 1, 3)
x.star <- rexp(5, lambda)
d <- sum((x-x.star)^2)
if(d < epsilon){
lambda.store[i] <- lambda
} else{
lambda.store[i] <- NA
}
}
return(mean(lambda.store))
}
abc.lambda <- numeric(51)
for(i in 50:100){
abc.lambda[i-49] <- abc.function(i)
}
x <- c(2.6863422, 8.8468112, 8.8781831, 0.2712696, 1.8902442)
n.iter <- 50000
lambda.store <- numeric(n.iter)
for(i in 1:n.iter){
lambda <-rbeta(1, 1, 3)
x.star <- rexp(5, lambda)
d <- sum((x-x.star)^2)
if(d < epsilon){
lambda.store[i] <- lambda
} else{
lambda.store[i] <- NA
}
}
hist(lambda.store)
mean(lambda.store)
epsilon <- 70
abc.function <- function(epsilon){
x <- c(2.6863422, 8.8468112, 8.8781831, 0.2712696, 1.8902442)
n.iter <- 50000
lambda.store <- numeric(n.iter)
for(i in 1:n.iter){
lambda <-rbeta(1, 1, 3)
x.star <- rexp(5, lambda)
d <- sum((x-x.star)^2)
if(d < epsilon){
lambda.store[i] <- lambda
} else{
lambda.store[i] <- NA
}
}
return(mean(lambda.store, na.rm = TRUE))
}
abc.lambda <- numeric(51)
for(i in 50:100){
abc.lambda[i-49] <- abc.function(i)
}
plot(abc.lambda)
plot((abc.lambda - 0.2)/0.2)
plot((abc.lambda - 0.2)/0.2*100)
for(i in 20:100){
abc.lambda[i-49] <- abc.function(i)
}
epsilon <- 20:100
abc.lambda <- numeric(length(epsilon))
for(i in 1:length(epsilon))
abc.lambda[i] <- abc.function(i)
plot((abc.lambda - 0.2)/0.2*100)
# Set Up ABC function -----------------------------------------------------
abc.function <- function(epsilon){
#input the value of epsilon
#Set Up ABC Algorithm
x <- c(2.6863422, 8.8468112, 8.8781831, 0.2712696, 1.8902442)
n.iter <- 50000
lambda.store <- numeric(n.iter)
#Run ABC
for(i in 1:n.iter){
#Propose lambda
lambda <-rbeta(1, 1, 3)
#Simulate data
x.star <- rexp(5, lambda)
d <- sum((x-x.star)^2)
#Accept Reject
if(d < epsilon){
lambda.store[i] <- lambda
} else{
lambda.store[i] <- NA
}
}
#Report median
return(median(lambda.store, na.rm = TRUE))
}
#Run for each value of epsilon
epsilon <- 20:100
abc.lambda <- numeric(length(epsilon))
for(i in 1:length(epsilon))
abc.lambda[i] <- abc.function(i)
#Report relative error
plot((abc.lambda - 0.2)/0.2*100)
#Report relative error
plot(epsilon, (abc.lambda - 0.2)/0.2*100, xlab = expression(epsilon), ylab = "Relative Error")
install.packages(mvtnomr)
install.packages(mvtnorm)
install.packages("mvtnorm")
a <- seq(0.5, 1, 0.001)
x <- dbinorm(a, 1000, 0.9)
a <- seq(0.5, 1, 0.001)
x <- dbinom(a, 1000, 0.9)
y <-  dbinrm(a, 1000, 0.8)
y <-  dbinom(a, 1000, 0.8)
plot(a, x, type = 'l', ylim = c(0, 20), xlab = expression(y),
ylab = "density")
warnings()
a <- 1:1000
x <- dbinom(a, 1000, 0.9)
y <-  dbinom(a, 1000, 0.8)
plot(a, x, type = 'l', ylim = c(0, 20), xlab = expression(y),
ylab = "density")
x
y
plot(a, x, type = 'l', xlab = expression(y),
ylab = "density")
lines(a, y, lty = 2)
y <-  dbinom(a, 1000, 0.85)
plot(a, x, type = 'l', xlab = expression(y),
ylab = "density")
lines(a, y, lty = 2)
a <- 1:1000
x <- dbinom(a, 1000, 0.9)
y <-  dbinom(a, 1000, 0.875)
plot(a, x, type = 'l', xlab = expression(y),
ylab = "density")
lines(a, y, lty = 2)
plot(a, x, type = 'l', xlab = expression(y),
ylab = "density", xlab = c(800, 1000))
lines(a, y, lty = 2)
plot(a, x, type = 'l', xlab = expression(y),
ylab = "density", xlim = c(800, 1000))
lines(a, y, lty = 2)
7+4+3+1
rgeom(1, 0.4)
rgeom(1, 0.4) + rgeom(2, 0.4)
rgeom(3, 0.4)
rgeom(20, 0.4)
rgeom(20, 0.9)
rgeom(20, 0.9)
rgeom(20, 0.25)
table(rgeom(20, 0.25))
table(rgeom(20, 0.25) + 1)
table(rgeom(20, 0.1) + 1)
table(rgeom(20, 0.5) + 1)
table(rgeom(20, 0.5) + 1)
value <- pgamma(0.9, 2*b, b)-0.9
cummulative.eqn <- function(b){
#Compute equation with value beta = b
value <- pgamma(0.9, 2*b, b)-0.9
return(value)
}
uniroot(cummulative.eqn, lower = 1, upper = 10)
uniroot(cummulative.eqn, lower = 0, upper = 10)
uniroot(cummulative.eqn, lower = 0, upper = 100)
uniroot(cummulative.eqn, lower = 0, upper = 1000)
uniroot(cummulative.eqn, lower = 1, upper = 1000)
cummulative.eqn <- function(b){
#Compute equation with value beta = b
value <- pgamma(0.9, 2*b, b)-0.0001
return(value)
}
uniroot(cummulative.eqn, lower = 1, upper = 1000)
cummulative.eqn <- function(b){
#Compute equation with value beta = b
value <- pgamma(0.9, 2*b, b)-0.0001
return(value)
}
uniroot(cummulative.eqn, lower = 1, upper = 1000)
?optim
optim(10, cummulative.eqn)
optim(10, cummulative.eqn, method = "Brent")
optim(10, cummulative.eqn, method = "Brent", , lower = 1, upper = 1000)
optim(10, cummulative.eqn, method = "Brent", lower = 1, upper = 1000)
optim(14, cummulative.eqn, method = "Brent", lower = 1, upper = 1000)
fr <- function(x) {   ## Rosenbrock Banana function
x1 <- x[1]
x2 <- x[2]
100 * (x2 - x1 * x1)^2 + (1 - x1)^2
}
grr <- function(x) { ## Gradient of 'fr'
x1 <- x[1]
x2 <- x[2]
c(-400 * x1 * (x2 - x1 * x1) - 2 * (1 - x1),
200 *      (x2 - x1 * x1))
}
optim(c(-1.2,1), fr)
(res <- optim(c(-1.2,1), fr, grr, method = "BFGS"))
uniroot(cummulative.eqn, lower = 1, upper = 1000)
optim(14, cummulative.eqn, method = "Brent", lower = 1, upper = 1000)
cummulative.eqn <- function(b){
#Compute equation with value beta = b
value <- pgamma(0.9, 2*b, b)-0.9999
return(value)
}
uniroot(cummulative.eqn, lower = 1, upper = 1000)
cummulative.eqn <- function(b){
#Compute equation with value beta = b
value <- pgamma(0.9, 8*b, b)-0.9999
return(value)
}
uniroot(cummulative.eqn, lower = 1, upper = 1000)
cummulative.eqn <- function(b){
#Compute equation with value beta = b
value <- pgamma(0.9, 8*b, b)-0.0001
return(value)
}
uniroot(cummulative.eqn, lower = 1, upper = 1000)
cummulative.eqn <- function(b){
#Compute equation with value beta = b
value <- pgamma(0.99, 8*b, b)-0.0001
return(value)
}
uniroot(cummulative.eqn, lower = 1, upper = 1000)
pgamma(0.99,7, 10)
pgamma(0.8,7, 10)
cummulative.eqn <- function(b){
#Compute equation with value beta = b
value <- pgamma(0.8, 0.7*b, b)-0.7
return(value)
}
uniroot(cummulative.eqn, lower = 1, upper = 1000)
pgamma(0.8, 0.7*13, 13)
uniroot(cummulative.eqn, lower = 1, upper = 1000)
0.75*13.2
cummulative.eqn <- function(b){
#Compute equation with value beta = b
value <- pgamma(0.7, 0.75*b, b)-0.8
return(value)
}
uniroot(cummulative.eqn, lower = 1, upper = 1000)
cummulative.eqn <- function(b){
#Compute equation with value beta = b
value <- pgamma(0.7, 0.75*b, b)-0.8
return(value)
}
uniroot(cummulative.eqn, lower = 1, upper = 1000)
cummulative.eqn(1)
cummulative.eqn(2)
cummulative.eqn(100)
#Compute equation with value beta = b
value <- pgamma(0.6, 0.75*b, b)-0.8
return(value)
cummulative.eqn <- function(b){
#Compute equation with value beta = b
value <- pgamma(0.6, 0.75*b, b)-0.8
return(value)
}
cummulative.eqn <- function(b){
#Compute equation with value beta = b
value <- pgamma(0.6, 0.75*b, b)-0.8
return(value)
}
uniroot(cummulative.eqn, lower = 1, upper = 1000)
cummulative.eqn <- function(b){
#Compute equation with value beta = b
value <- pgamma(0.9, 0.75*b, b)-0.8
return(value)
}
uniroot(cummulative.eqn, lower = 1, upper = 1000)
0.745
0.75*21.8
x <- runif(5)
x1 <- runif(5)
x1 <- runif(5)
x2 <- runif(5)
x3 <- runif(5)
x4 <- runif(5)
x <- data.frame(x1, x2, x3, x4)
x
pairs(x)
library(dplyr)
install.packages("dplyr")
install.packages("dplyr")
install.packages("dplyr")
install.packages("dplyr")
install.packages("rstan")
library(dplyr)
library(rstan)
options(scipen=999)
killworth <- function(ard, known.group.indices, known.group.sizes, total.pop.size) {
num.respondents <- nrow(ard)
degrees <- vector(length=num.respondents)
for(respondent in 1:num.respondents){
degrees[respondent] <- total.pop.size * ( sum(ard[respondent, known.group.indices]) / sum(known.group.sizes) )
}
copy.ard <- ard
knew.none <- which(degrees == 0)
if(length(knew.none) == num.respondents){
return(rep(0, ncol(ard) - length(known.group.indices)))
}
if(length(knew.none) > 0){
degrees <- degrees[-knew.none]
copy.ard <- ard[-knew.none,]
}
if(is.matrix(copy.ard)){
key.respondents <- copy.ard[,-known.group.indices]
}else{
key.respondents <- copy.ard[-known.group.indices]
}
if(is.vector(key.respondents)){
return(pmin( key.respondents / degrees, 1))
}
unknown.group.estimates <- colSums(key.respondents) / sum(degrees)
return(unknown.group.estimates)
}
generate.binomial.ard <- function(num.respondents, num.subpopulations, total.pop.size, p.k){
rho_j <- rbinom(n=num.subpopulations, size=total.pop.size, prob = p.k)
degree_mu <- runif(1, min=3, max=5)
degree_sd <- runif(1, min=0.25, max=1.5)
degrees <- rlnorm(num.respondents, meanlog=degree_mu,
sdlog=degree_sd) %>% round
degrees <- pmin(degrees, total.pop.size)
ard <- matrix(0, nrow=num.respondents, ncol=num.subpopulations)
for(respondent in 1:num.respondents){
ard[respondent,] <- rbinom(num.subpopulations, size=degrees[respondent],
prob=rho_j/total.pop.size)
}
return(ard)
}
num.respondents <- 20
num.subpopulations <- 5
total.pop.size <- 1000000
p.k <- c(0.085, 0.067, 0.071, 0.014, 0.031)
generate.nb.ard <- function(num.respondents, num.subpopulations, total.pop.size, p.k){
rho_j <- log(p.k)
delta <- rweibull(num.respondents, shape=35, scale=10) * -1
tau_n <- rep(0.2, num.subpopulations)
mu  <- log(1 / sqrt(1 + (tau_n)**2))
tau <- sqrt(1 + (tau_n)**2)
corr.matrix <- matrix(c(1, 0.5, 0.23, 0, 0.1,
0.5, 1, 0.71, -0.1, 0.05,
0.23, 0.71, 1, 0.13, 0.23,
0, -0.1, 0.13, 1, 0.7,
0.1, 0.05, 0.23, 0.7, 1),
nrow=num.subpopulations,
ncol = num.subpopulations)
L <- t(chol(corr.matrix))
rho_j <- matrix(rho_j, nrow=num.respondents,
ncol=num.subpopulations,
byrow = T)
norm.errors <- matrix(rnorm(num.respondents * num.subpopulations, mean=0, sd=1),
ncol=num.subpopulations)
lambda <- exp(rho_j + matrix(rep(delta, times=num.subpopulations), ncol=num.subpopulations) +
matrix(rep(mu, each=num.respondents), ncol=num.subpopulations) +
t(diag(tau) %*% L %*% t(norm.errors))) * total.pop.size
w <- rcauchy(num.subpopulations, location=0, scale=2.5) %>% abs
ard <- matrix(rnbinom(n=num.respondents * num.subpopulations, mu=lambda, size=w),
ncol=num.subpopulations)
return(ard)
}
compute.correlation.samples <- function(params){
L <- params$L
iterations <- dim(L)[1]
num.groups <- dim(L)[2]
correlation <- array(dim=c(iterations, num.groups, num.groups))
for(iter in 1:iterations){
correlation[iter, , ] <- L[iter, , ] %*% t(L[iter, , ])
}
return(correlation)
}
correlatedScaling <- function(rho, correlation,
raw_known_sizes,
population_size){
iterations <- nrow(rho)
K <- ncol(rho)
new_rho <- rho
known_ind <- which(raw_known_sizes > 0)
for(k in 1:K){
for(iter in 1:iterations){
l_known_ind <- setdiff(known_ind, k)
num_known <- length(l_known_ind)
w <- correlation[iter, k, l_known_ind]
w[w < 0] <- 0
w <- w * ( num_known / sum(w) )
known_sizes <- raw_known_sizes[-k]
known_sizes <- known_sizes[which(known_sizes > 0)]
C_m  <- log( (1/(num_known)) *
sum( (exp(rho[iter, l_known_ind]) * w ) / (unlist(known_sizes)/population_size)) )
new_rho[iter, k] <- rho[iter, k] - C_m
}
}
return(new_rho)
}
set.seed(855)
p.k <- c(0.085, 0.067, 0.071, 0.014, 0.031)
num.subpopulations <- length(p.k)
shape.rho <- rweibull(num.subpopulations, shape=8.5, scale=5.5)
rate.rho  <- rweibull(num.subpopulations, shape=3.5, scale=1)
num.regions <- 150
rho_j <- matrix(0, ncol=num.subpopulations, nrow=num.regions)
for(region in 1:num.regions){
rho_j[region,]  <- -rgamma(num.subpopulations, shape=shape.rho, rate=rate.rho) %>%
sort(decreasing = T) %>% pmax(-17)
}
library(dplyr)
install.packages("rland")
install.packages("rlang")
install.packages("rlang")
library(dplyr)
library(dplyr)
library(rlang)
