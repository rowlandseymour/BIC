rho_j <- matrix(0, ncol=num.subpopulations, nrow=num.regions)
for(region in 1:num.regions){
rho_j[region,]  <- rbeta(num.subpopulations, alpha.rho, beta.rho) %>%
sort(decreasing = T) %>% pmax(-17)
}
all.p.k <- rho_j
colnames(all.p.k) <- paste0('subpopulation_', 1:num.subpopulations)
all.p.k %>% head(20)
rbeta(num.subpopulations, alpha.rho, beta.rho)
rbeta(num.subpopulations, alpha.rho, beta.rho)
rbeta(num.subpopulations, alpha.rho, beta.rho)
rbeta(num.subpopulations, alpha.rho, beta.rho)
rbeta(num.subpopulations, alpha.rho, beta.rho)
alpha.rho
beta.rho
alpha.rho/beta.rho
-mu*(mu*(1-mu)/sigma.sq - 1)
alpha.mu*mu*(1-mu)/mu
mu*(mu*(1-mu)/sigma.sq - 1)
alpha.mu/(alpha.mu + beta.mu)
alpha.rho/(alpha.rho + beta.rho)
alpha.rho <- mu*(mu*(1-mu)/sigma.sq - 1)
beta.rho  <- alpha.mu*(1-mu)/mu
num.regions <- 150
rho_j <- matrix(0, ncol=num.subpopulations, nrow=num.regions)
for(region in 1:num.regions){
rho_j[region,]  <- rbeta(num.subpopulations, alpha.rho, beta.rho) %>%
sort(decreasing = T) %>% pmax(-17)
}
all.p.k <- rho_j
colnames(all.p.k) <- paste0('subpopulation_', 1:num.subpopulations)
all.p.k %>% head(20)
rbeta(num.subpopulations, alpha.rho, beta.rho)
rbeta(num.subpopulations, alpha.rho, beta.rho)
rbeta(num.subpopulations, alpha.rho, beta.rho)
rbeta(num.subpopulations, alpha.rho, beta.rho)
rbeta(num.subpopulations, alpha.rho, beta.rho)
curve(dbeta(x, alpha.rho, beta.rho), 0, 1)
mu <- 0.2
sigma.sq <- 0.1
alpha.rho <- mu*(mu*(1-mu)/sigma.sq - 1)
beta.rho  <- alpha.mu*(1-mu)/mu
mu <- 0.2
sigma.sq <- 0.1
alpha.rho <- mu*(mu*(1-mu)/sigma.sq - 1)
beta.rho  <- alpha.rho*(1-mu)/mu
curve(dbeta(x, alpha.rho, beta.rho), 0, 1)
num.regions <- 150
rho_j <- matrix(0, ncol=num.subpopulations, nrow=num.regions)
for(region in 1:num.regions){
rho_j[region,]  <- rbeta(num.subpopulations, alpha.rho, beta.rho) %>%
sort(decreasing = T) %>% pmax(-17)
}
all.p.k <- rho_j
colnames(all.p.k) <- paste0('subpopulation_', 1:num.subpopulations)
all.p.k %>% head(20)
sigma.sq <- 0.01
alpha.rho <- mu*(mu*(1-mu)/sigma.sq - 1)
beta.rho  <- alpha.rho*(1-mu)/mu
curve(dbeta(x, alpha.rho, beta.rho), 0, 1)
num.regions <- 150
rho_j <- matrix(0, ncol=num.subpopulations, nrow=num.regions)
for(region in 1:num.regions){
rho_j[region,]  <- rbeta(num.subpopulations, alpha.rho, beta.rho) %>%
sort(decreasing = T) %>% pmax(-17)
}
all.p.k <- rho_j
colnames(all.p.k) <- paste0('subpopulation_', 1:num.subpopulations)
all.p.k %>% head(20)
spatial.results <- matrix(0, ncol=3) %>% as.data.frame()
known.group.indices <- c(1, 2, 3)
unknown.group.indices <- setdiff(1:num.subpopulations, known.group.indices)
colnames(spatial.results) <- c('num_respondents', 'mean_error', 'model')
sim.num.respondents <- c(5, 10, 15, 20, 25, 40)
population <- 1000000
spatial.results
unknown.group.indices
colnames(spatial.results)
alpha.rho/(alpha.rho + beta.rho)
um.regions <- 150
num.respondents <- 20
cat(paste('Currently simulating with', num.respondents, 'respondents'), '\n')
ard <- matrix(0, ncol=num.subpopulations)
for(region in 1:num.regions){
# Generate NB data for multiple regions and estimate the prevalence
# using the NB model and correlated scaling
p.k <- as.numeric(all.p.k[region, ])
nb.ard <- generate.nb.ard(num.respondents = num.respondents,
num.subpopulations = length(p.k),
total.pop.size = population,
p.k = p.k)
ard <- rbind(ard, nb.ard)
}
ard <- ard[-1,]
data <- list(N = nrow(ard),
K = ncol(ard),
y = ard,
offset = rep(population, nrow(ard)),
J = num.regions,
jj = rep(1:num.regions, each=num.respondents))
ard
hist(ard[, 5])
table(ard[, 5])
alpha.rho
beta.rho
3/(3 + 12)
temp <- rbeta(num.subpopulations, alpha.rho, beta.rho)
temp
log(temp)
-1*log(temp)
num.regions <- 150
rho_j <- matrix(0, ncol=num.subpopulations, nrow=num.regions)
for(region in 1:num.regions){
rho_j[region,]  <- rbeta(num.subpopulations, alpha.rho, beta.rho) %>%
sort(decreasing = T) %>% pmax(-17)
}
all.p.k <- rho_j
colnames(all.p.k) <- paste0('subpopulation_', 1:num.subpopulations)
all.p.k %>% head(20)
spatial.results <- matrix(0, ncol=3) %>% as.data.frame()
known.group.indices <- c(1, 2, 3)
unknown.group.indices <- setdiff(1:num.subpopulations, known.group.indices)
colnames(spatial.results) <- c('num_respondents', 'mean_error', 'model')
sim.num.respondents <- c(5, 10, 15, 20, 25, 40)
population <- 1000000
model <- stan_model('~/Desktop/corr_neg_binomial_partial_pooling.stan')
model <- stan_model('~/Desktop/corr_neg_binomial_partial_pooling.stan')
num.regions <- 150
num.respondents <- 20
cat(paste('Currently simulating with', num.respondents, 'respondents'), '\n')
ard <- matrix(0, ncol=num.subpopulations)
for(region in 1:num.regions){
# Generate NB data for multiple regions and estimate the prevalence
# using the NB model and correlated scaling
p.k <- as.numeric(all.p.k[region, ])
nb.ard <- generate.nb.ard(num.respondents = num.respondents,
num.subpopulations = length(p.k),
total.pop.size = population,
p.k = p.k)
ard <- rbind(ard, nb.ard)
}
ard <- ard[-1,]
ard
data <- list(N = nrow(ard),
K = ncol(ard),
y = ard,
offset = rep(population, nrow(ard)),
J = num.regions,
jj = rep(1:num.regions, each=num.respondents))
fit <- sampling(model, data = data, warmup=500,
iter = 1500, cores=20,
chains = 2, seed=73, verbose=F, show_messages=F)
trace(fit)
traceplot(fit)
mu <- 0.2
sigma.sq <- 0.01
alpha.rho <-mu^2/sigma.sq
beta.rho  <- sigma.sq/mu
mu <- 0.2
sigma.sq <- 0.01
alpha.rho <-mu^2/sigma.sq
beta.rho  <- sigma.sq/mu
curve(exp(-dgamma(x, alpha.rho, beta.rho), 0, 1)
)
curve(exp(-dgamma(x, alpha.rho, beta.rho)), 0, 1)
mu <- 0.2
sigma.sq <- 0.1
alpha.rho <-mu^2/sigma.sq
beta.rho  <- sigma.sq/mu
curve(exp(-dgamma(x, alpha.rho, beta.rho)), 0, 1)
mu <- 0.2
sigma.sq <- 0.001
alpha.rho <-mu^2/sigma.sq
beta.rho  <- sigma.sq/mu
curve(exp(-dgamma(x, alpha.rho, beta.rho)), 0, 1)
mu <- 0.2
sigma.sq <- 0.01
alpha.rho <-mu^2/sigma.sq
beta.rho  <- sigma.sq/mu
curve(exp(-dgamma(x, alpha.rho, beta.rho)), 0, 1)
curve(exp(-dgamma(x, alpha.rho, beta.rho)), 0, 10)
dgamm(10, alpha.rho, beta.rho)
dgamma(10, alpha.rho, beta.rho)
rgamma(10, alpha.rho, beta.rho)
log(gamma(10, alpha.rho, beta.rho))
log(dgamma(10, alpha.rho, beta.rho))
log(rgamma(10, alpha.rho, beta.rho))
log(-rgamma(10, alpha.rho, beta.rho))
log(rgamma(10, alpha.rho, beta.rho))
exp(-rgamma(10, alpha.rho, beta.rho))
mu <- 0.5
sigma.sq <- 0.01
alpha.rho <-mu^2/sigma.sq
beta.rho  <- sigma.sq/mu
curve(exp(-dgamma(x, alpha.rho, beta.rho)), 0, 1)
mu <- 0.8
sigma.sq <- 0.01
alpha.rho <-mu^2/sigma.sq
beta.rho  <- sigma.sq/mu
curve(exp(-dgamma(x, alpha.rho, beta.rho)), 0, 1)
hist(exp(-rgamma(10000, alpha.rho, beta.rho)))
exp(-rgamma(100, alpha.rho, beta.rho))
alpha.rho
beta.rho
mu <- 0.2
sigma.sq <- 2
alpha.rho <-mu^2/sigma.sq
beta.rho  <- sigma.sq/mu
curve(exp(-dgamma(x, alpha.rho, beta.rho)), 0, 1)
hist(exp(-rgamma(100, alpha.rho, beta.rho)))
curve(exp(-dgamma(x, alpha.rho, beta.rho)), 0, 1)
sigma.sq <- 5
alpha.rho <-mu^2/sigma.sq
beta.rho  <- sigma.sq/mu
curve(exp(-dgamma(x, alpha.rho, beta.rho)), 0, 1)
sigma.sq <- 1
alpha.rho <-mu^2/sigma.sq
beta.rho  <- sigma.sq/mu
curve(exp(-dgamma(x, alpha.rho, beta.rho)), 0, 1)
mu <- 0.2
sigma.sq <- 1
alpha.rho <-mu^2/sigma.sq
beta.rho  <- mu/sigma.sq
curve(exp(-dgamma(x, alpha.rho, beta.rho)), 0, 1)
sigma.sq <- 0.1
alpha.rho <-mu^2/sigma.sq
beta.rho  <- mu/sigma.sq
curve(exp(-dgamma(x, alpha.rho, beta.rho)), 0, 1)
sigma.sq <- 0.01
alpha.rho <-mu^2/sigma.sq
beta.rho  <- mu/sigma.sq
curve(exp(-dgamma(x, alpha.rho, beta.rho)), 0, 1)
sigma.sq <- 0.001
alpha.rho <-mu^2/sigma.sq
beta.rho  <- mu/sigma.sq
curve(exp(-dgamma(x, alpha.rho, beta.rho)), 0, 1)
sigma.sq <- 10
alpha.rho <-mu^2/sigma.sq
beta.rho  <- mu/sigma.sq
curve(exp(-dgamma(x, alpha.rho, beta.rho)), 0, 1)
sigma.sq <- 0.5
alpha.rho <-mu^2/sigma.sq
beta.rho  <- mu/sigma.sq
curve(exp(-dgamma(x, alpha.rho, beta.rho)), 0, 1)
num.regions <- 150
rho_j <- matrix(0, ncol=num.subpopulations, nrow=num.regions)
for(region in 1:num.regions){
rho_j[region,]  <- -rgamma(num.subpopulations, alpha.rho, beta.rho) %>%
sort(decreasing = T) %>% pmax(-17)
}
all.p.k <- rho_j %>% exp()
colnames(all.p.k) <- paste0('subpopulation_', 1:num.subpopulations)
all.p.k %>% head(20)
mu <- 0.2
sigma.sq <- 0.1
alpha.rho <-mu^2/sigma.sq
beta.rho  <- mu/sigma.sq
curve(exp(-dgamma(x, alpha.rho, beta.rho)), 0, 1)
mu <- 0.2
sigma.sq <- 0.01
alpha.rho <-mu^2/sigma.sq
beta.rho  <- mu/sigma.sq
curve(exp(-dgamma(x, alpha.rho, beta.rho)), 0, 1)
mu <- 0.2
sigma.sq <- 0.01
alpha.rho <- mu*(mu*(1-mu)/sigma.sq - 1)
beta.rho  <- alpha.rho*(1-mu)/mu
curve(dbeta(x, alpha.rho, beta.rho), 0, 1)
curve(exp(-dgamma(x, 64, 16)), 0, 1)
#Gamma
require(limma)
#Gamma
require(trigammaInverse)
install.packages("limma")
install.packages("trigammaInverse")
#Gamma
require(MAnorm2)
install.packages("MAnorm2")
#Gamma
require(MAnorm2)
alpha.rho <- inv.trigamma(sigma.sq)
alpha.rho
beta.rho  <- exp(mu + digamma(alpha.rho))
beta.rho
curve(exp(-dgamma(x, alpha.rho, beta.rho)), 0, 1)
sigma.sq <- 0.1
alpha.rho <- inv.trigamma(sigma.sq)
beta.rho  <- exp(mu + digamma(alpha.rho))
curve(exp(-dgamma(x, alpha.rho, beta.rho)), 0, 1)
num.regions <- 150
rho_j <- matrix(0, ncol=num.subpopulations, nrow=num.regions)
for(region in 1:num.regions){
rho_j[region,]  <- -rgamma(num.subpopulations, alpha.rho, beta.rho) %>%
sort(decreasing = T) %>% pmax(-17)
}
all.p.k <- rho_j %>% exp()
colnames(all.p.k) <- paste0('subpopulation_', 1:num.subpopulations)
all.p.k %>% head(20)
alpha.rho
beta.rho]
beta.rho
spatial.results <- matrix(0, ncol=3) %>% as.data.frame()
known.group.indices <- c(1, 2, 3)
unknown.group.indices <- setdiff(1:num.subpopulations, known.group.indices)
colnames(spatial.results) <- c('num_respondents', 'mean_error', 'model')
sim.num.respondents <- c(5, 10, 15, 20, 25, 40)
population <- 1000000
model <- stan_model('~/Desktop/corr_neg_binomial_partial_pooling.stan')
num.regions <- 150
num.respondents <- 20
cat(paste('Currently simulating with', num.respondents, 'respondents'), '\n')
ard <- matrix(0, ncol=num.subpopulations)
for(region in 1:num.regions){
# Generate NB data for multiple regions and estimate the prevalence
# using the NB model and correlated scaling
p.k <- as.numeric(all.p.k[region, ])
nb.ard <- generate.nb.ard(num.respondents = num.respondents,
num.subpopulations = length(p.k),
total.pop.size = population,
p.k = p.k)
ard <- rbind(ard, nb.ard)
}
ard <- ard[-1,]
ard
data <- list(N = nrow(ard),
K = ncol(ard),
y = ard,
offset = rep(population, nrow(ard)),
J = num.regions,
jj = rep(1:num.regions, each=num.respondents))
fit <- sampling(model, data = data, warmup=500,
iter = 1500, cores=20,
chains = 2, seed=73, verbose=F, show_messages=F)
traceplot(fit)
params <- extract(fit)
rho_j <- params$rho_j
rho_j
##Beta
mu <- 0.2
sigma.sq <- 0.01
alpha.rho <- mu*(mu*(1-mu)/sigma.sq - 1)
beta.rho  <- alpha.rho*(1-mu)/mu
curve(dbeta(x, alpha.rho, beta.rho), 0, 1)
num.regions <- 150
rho_j <- matrix(0, ncol=num.subpopulations, nrow=num.regions)
for(region in 1:num.regions){
rho_j[region,]  <- rbeta(num.subpopulations, alpha.rho, beta.rho) %>%
sort(decreasing = T) %>% pmax(-17)
}
all.p.k <- rho_j %>% exp()
colnames(all.p.k) <- paste0('subpopulation_', 1:num.subpopulations)
all.p.k %>% head(20)
num.regions <- 150
rho_j <- matrix(0, ncol=num.subpopulations, nrow=num.regions)
for(region in 1:num.regions){
rho_j[region,]  <- rbeta(num.subpopulations, alpha.rho, beta.rho) %>%
sort(decreasing = T) %>% pmax(-17)
}
all.p.k <- rho_j
colnames(all.p.k) <- paste0('subpopulation_', 1:num.subpopulations)
all.p.k %>% head(20)
spatial.results <- matrix(0, ncol=3) %>% as.data.frame()
known.group.indices <- c(1, 2, 3)
unknown.group.indices <- setdiff(1:num.subpopulations, known.group.indices)
colnames(spatial.results) <- c('num_respondents', 'mean_error', 'model')
sim.num.respondents <- c(5, 10, 15, 20, 25, 40)
population <- 1000000
num.regions <- 150
num.respondents <- 20
cat(paste('Currently simulating with', num.respondents, 'respondents'), '\n')
ard <- matrix(0, ncol=num.subpopulations)
for(region in 1:num.regions){
# Generate NB data for multiple regions and estimate the prevalence
# using the NB model and correlated scaling
p.k <- as.numeric(all.p.k[region, ])
nb.ard <- generate.nb.ard(num.respondents = num.respondents,
num.subpopulations = length(p.k),
total.pop.size = population,
p.k = p.k)
ard <- rbind(ard, nb.ard)
}
ard <- ard[-1,]
ard
colMeans(ard)
mu <- 0.1
sigma.sq <- 0.1
alpha.rho <- inv.trigamma(sigma.sq)
beta.rho  <- exp(mu + digamma(alpha.rho))
curve(exp(-dgamma(x, alpha.rho, beta.rho)), 0, 1)
mu <- 0.2
sigma.sq <- 0.01
alpha.rho <- mu*(mu*(1-mu)/sigma.sq - 1)
beta.rho  <- alpha.rho*(1-mu)/mu
curve(dbeta(x, alpha.rho, beta.rho), 0, 1)
mu <- 0.1
sigma.sq <- 0.01
alpha.rho <- mu*(mu*(1-mu)/sigma.sq - 1)
beta.rho  <- alpha.rho*(1-mu)/mu
curve(dbeta(x, alpha.rho, beta.rho), 0, 1)
num.regions <- 150
rho_j <- matrix(0, ncol=num.subpopulations, nrow=num.regions)
for(region in 1:num.regions){
rho_j[region,]  <- rbeta(num.subpopulations, alpha.rho, beta.rho) %>%
sort(decreasing = T) %>% pmax(-17)
}
all.p.k <- rho_j
colnames(all.p.k) <- paste0('subpopulation_', 1:num.subpopulations)
all.p.k %>% head(20)
spatial.results <- matrix(0, ncol=3) %>% as.data.frame()
known.group.indices <- c(1, 2, 3)
unknown.group.indices <- setdiff(1:num.subpopulations, known.group.indices)
colnames(spatial.results) <- c('num_respondents', 'mean_error', 'model')
sim.num.respondents <- c(5, 10, 15, 20, 25, 40)
population <- 1000000
num.regions <- 150
num.respondents <- 20
cat(paste('Currently simulating with', num.respondents, 'respondents'), '\n')
ard <- matrix(0, ncol=num.subpopulations)
for(region in 1:num.regions){
# Generate NB data for multiple regions and estimate the prevalence
# using the NB model and correlated scaling
p.k <- as.numeric(all.p.k[region, ])
nb.ard <- generate.nb.ard(num.respondents = num.respondents,
num.subpopulations = length(p.k),
total.pop.size = population,
p.k = p.k)
ard <- rbind(ard, nb.ard)
}
ard <- ard[-1,]
colMeans(ard)
mu <- 4
sigma.sq <- 2
alpha.rho <- (mu**2)/sigma.sq
beta.rho <- mu/sigma.sq
curve(dgamma(x, alpha.rho, beta.rho), 0, 10)
curve(exp(-dgamma(x, alpha.rho, beta.rho)), 0, 10)
curve(dgamma(x, alpha.rho, beta.rho), 0, 10)
mu <- 4
sigma.sq <- 2
alpha.rho <- (mu**2)/sigma.sq
beta.rho <- mu/sigma.sq
curve(dgamma(x, alpha.rho, beta.rho), 0, 10)
curve(-dgamma(x, alpha.rho, beta.rho), 0, 10)
curve(dgamma(x, alpha.rho, beta.rho), 0, 10)
mu <-  0.1
sigma.sq <- 0.1
alpha.rho <- inv.trigamma(sigma.sq)
beta.rho  <- exp(mu + digamma(alpha.rho))
curve(dgamma(x, alpha.rho, beta.rho), 0, 1)
alpha.rho <- (mu**2)/sigma.sq
beta.rho <- mu/sigma.sq
curve(dgamma(x, alpha.rho, beta.rho), 0, 1)
mu <-  0.1
sigma.sq <- 0.1
alpha.rho <- (mu**2)/sigma.sq
beta.rho <- mu/sigma.sq
curve(dgamma(x, alpha.rho, beta.rho), 0, 1)
mu <-  0.1
sigma.sq <- 0.01
alpha.rho <- (mu**2)/sigma.sq
beta.rho <- mu/sigma.sq
curve(dgamma(x, alpha.rho, beta.rho), 0, 1)
num.regions <- 150
rho_j <- matrix(0, ncol=num.subpopulations, nrow=num.regions)
for(region in 1:num.regions){
rho_j[region,]  <- -rgamma(num.subpopulations, alpha.rho, beta.rho) %>%
sort(decreasing = T) %>% pmax(-17)
}
all.p.k <- rho_j
colnames(all.p.k) <- paste0('subpopulation_', 1:num.subpopulations)
all.p.k %>% head(20)
all.p.k <- rho_j %>% exp()
colnames(all.p.k) <- paste0('subpopulation_', 1:num.subpopulations)
all.p.k %>% head(20)
mu <-  4
sigma.sq <- 2
alpha.rho <- (mu**2)/sigma.sq
beta.rho <- mu/sigma.sq
curve(dgamma(x, alpha.rho, beta.rho), 0, 1)
num.regions <- 150
rho_j <- matrix(0, ncol=num.subpopulations, nrow=num.regions)
for(region in 1:num.regions){
rho_j[region,]  <- -rgamma(num.subpopulations, alpha.rho, beta.rho) %>%
sort(decreasing = T) %>% pmax(-17)
}
all.p.k <- rho_j %>% exp()
all.p.k <- rho_j %>% exp()
colnames(all.p.k) <- paste0('subpopulation_', 1:num.subpopulations)
all.p.k %>% head(20)
require(MAnorm2)
mu <-  2
sigma.sq <- 1
alpha.rho <- (mu**2)/sigma.sq
beta.rho <- mu/sigma.sq
curve(dgamma(x, alpha.rho, beta.rho), 0, 1)
num.regions <- 150
rho_j <- matrix(0, ncol=num.subpopulations, nrow=num.regions)
for(region in 1:num.regions){
rho_j[region,]  <- -rgamma(num.subpopulations, alpha.rho, beta.rho) %>%
sort(decreasing = T) %>% pmax(-17)
}
all.p.k <- rho_j %>% exp()
colnames(all.p.k) <- paste0('subpopulation_', 1:num.subpopulations)
all.p.k %>% head(20)
curve(dgamma(x, alpha.rho, beta.rho), 0, 10)
spatial.results <- matrix(0, ncol=3) %>% as.data.frame()
known.group.indices <- c(1, 2, 3)
unknown.group.indices <- setdiff(1:num.subpopulations, known.group.indices)
colnames(spatial.results) <- c('num_respondents', 'mean_error', 'model')
sim.num.respondents <- c(5, 10, 15, 20, 25, 40)
population <- 1000000
model <- stan_model('~/Desktop/corr_neg_binomial_partial_pooling.stan')
